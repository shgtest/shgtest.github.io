/*
Copyright 2014, KISSY v1.42
MIT Licensed
build time: Feb 26 18:57
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 dom/base/api
 dom/base/attr
 dom/base/class
 dom/base/create
 dom/base/data
 dom/base/insertion
 dom/base/offset
 dom/base/style
 dom/base/selector
 dom/base/traversal
 dom/base
*/

KISSY.add("dom/base/api", [], function(S) {
  var WINDOW = S.Env.host || {}, DOCUMENT = WINDOW.document, UA = S.UA, RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, NodeType = {ELEMENT_NODE:1, ATTRIBUTE_NODE:2, TEXT_NODE:3, CDATA_SECTION_NODE:4, ENTITY_REFERENCE_NODE:5, ENTITY_NODE:6, PROCESSING_INSTRUCTION_NODE:7, COMMENT_NODE:8, DOCUMENT_NODE:9, DOCUMENT_TYPE_NODE:10, DOCUMENT_FRAGMENT_NODE:11, NOTATION_NODE:12}, Dom = {isCustomDomain:function(win) {
    win = win || WINDOW;
    win = Dom.get(win);
    var domain = win.document.domain, hostname = win.location.hostname;
    return domain !== hostname && domain !== "[" + hostname + "]"
  }, getEmptyIframeSrc:function(win) {
    win = win || WINDOW;
    win = Dom.get(win);
    if(UA.ie && Dom.isCustomDomain(win)) {
      return"javascript:void(function(){" + encodeURIComponent("document.open();" + 'document.domain="' + win.document.domain + '";' + "document.close();") + "}())"
    }
    return""
  }, NodeType:NodeType, getWindow:function(elem) {
    if(!elem) {
      return WINDOW
    }
    elem = Dom.get(elem);
    if(S.isWindow(elem)) {
      return elem
    }
    var doc = elem;
    if(doc.nodeType !== NodeType.DOCUMENT_NODE) {
      doc = elem.ownerDocument
    }
    return doc.defaultView || doc.parentWindow
  }, getDocument:function(elem) {
    if(!elem) {
      return DOCUMENT
    }
    elem = Dom.get(elem);
    return S.isWindow(elem) ? elem.document : elem.nodeType === NodeType.DOCUMENT_NODE ? elem : elem.ownerDocument
  }, isDomNodeList:function(o) {
    return o && !o.nodeType && o.item && !o.setTimeout
  }, nodeName:function(selector) {
    var el = Dom.get(selector), nodeName = el.nodeName.toLowerCase();
    if(UA.ie) {
      var scopeName = el.scopeName;
      if(scopeName && scopeName !== "HTML") {
        nodeName = scopeName.toLowerCase() + ":" + nodeName
      }
    }
    return nodeName
  }, _RE_NUM_NO_PX:new RegExp("^(" + RE_NUM + ")(?!px)[a-z%]+$", "i")};
  S.mix(Dom, NodeType);
  return Dom
});
KISSY.add("dom/base/attr", ["./api"], function(S, require) {
  var Dom = require("./api");
  var doc = S.Env.host.document, NodeType = Dom.NodeType, docElement = doc && doc.documentElement, EMPTY = "", nodeName = Dom.nodeName, R_BOOLEAN = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i, R_FOCUSABLE = /^(?:button|input|object|select|textarea)$/i, R_CLICKABLE = /^a(?:rea)?$/i, R_INVALID_CHAR = /:|^on/, R_RETURN = /\r/g, attrFix = {}, attrFn = {val:1, css:1, html:1, text:1, data:1, width:1, height:1, offset:1, scrollTop:1, 
  scrollLeft:1}, attrHooks = {tabindex:{get:function(el) {
    var attributeNode = el.getAttributeNode("tabindex");
    return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : R_FOCUSABLE.test(el.nodeName) || R_CLICKABLE.test(el.nodeName) && el.href ? 0 : undefined
  }}}, propFix = {hidefocus:"hideFocus", tabindex:"tabIndex", readonly:"readOnly", "for":"htmlFor", "class":"className", maxlength:"maxLength", cellspacing:"cellSpacing", cellpadding:"cellPadding", rowspan:"rowSpan", colspan:"colSpan", usemap:"useMap", frameborder:"frameBorder", contenteditable:"contentEditable"}, boolHook = {get:function(elem, name) {
    return Dom.prop(elem, name) ? name.toLowerCase() : undefined
  }, set:function(elem, value, name) {
    var propName;
    if(value === false) {
      Dom.removeAttr(elem, name)
    }else {
      propName = propFix[name] || name;
      if(propName in elem) {
        elem[propName] = true
      }
      elem.setAttribute(name, name.toLowerCase())
    }
    return name
  }}, propHooks = {}, attrNodeHook = {}, valHooks = {select:{get:function(elem) {
    var index = elem.selectedIndex, options = elem.options, ret, i, len, one = String(elem.type) === "select-one";
    if(index < 0) {
      return null
    }else {
      if(one) {
        return Dom.val(options[index])
      }
    }
    ret = [];
    i = 0;
    len = options.length;
    for(;i < len;++i) {
      if(options[i].selected) {
        ret.push(Dom.val(options[i]))
      }
    }
    return ret
  }, set:function(elem, value) {
    var values = S.makeArray(value), opts = elem.options;
    S.each(opts, function(opt) {
      opt.selected = S.inArray(Dom.val(opt), values)
    });
    if(!values.length) {
      elem.selectedIndex = -1
    }
    return values
  }}};
  S.each(["radio", "checkbox"], function(r) {
    valHooks[r] = {get:function(elem) {
      return elem.getAttribute("value") === null ? "on" : elem.value
    }, set:function(elem, value) {
      if(S.isArray(value)) {
        elem.checked = S.inArray(Dom.val(elem), value);
        return 1
      }
      return undefined
    }}
  });
  attrHooks.style = {get:function(el) {
    return el.style.cssText
  }};
  function toStr(value) {
    return value == null ? "" : value + ""
  }
  function getProp(elem, name) {
    name = propFix[name] || name;
    var hook = propHooks[name];
    if(hook && hook.get) {
      return hook.get(elem, name)
    }else {
      return elem[name]
    }
  }
  S.mix(Dom, {_valHooks:valHooks, _propFix:propFix, _attrHooks:attrHooks, _propHooks:propHooks, _attrNodeHook:attrNodeHook, _attrFix:attrFix, prop:function(selector, name, value) {
    var elems = Dom.query(selector), i, elem, hook;
    if(S.isPlainObject(name)) {
      S.each(name, function(v, k) {
        Dom.prop(elems, k, v)
      });
      return undefined
    }
    name = propFix[name] || name;
    hook = propHooks[name];
    if(value !== undefined) {
      for(i = elems.length - 1;i >= 0;i--) {
        elem = elems[i];
        if(hook && hook.set) {
          hook.set(elem, value, name)
        }else {
          elem[name] = value
        }
      }
    }else {
      if(elems.length) {
        return getProp(elems[0], name)
      }
    }
    return undefined
  }, hasProp:function(selector, name) {
    var elems = Dom.query(selector), i, len = elems.length, el;
    for(i = 0;i < len;i++) {
      el = elems[i];
      if(getProp(el, name) !== undefined) {
        return true
      }
    }
    return false
  }, removeProp:function(selector, name) {
    name = propFix[name] || name;
    var elems = Dom.query(selector), i, el;
    for(i = elems.length - 1;i >= 0;i--) {
      el = elems[i];
      try {
        el[name] = undefined;
        delete el[name]
      }catch(e) {
      }
    }
  }, attr:function(selector, name, val, pass) {
    var els = Dom.query(selector), attrNormalizer, i, el = els[0], ret;
    if(S.isPlainObject(name)) {
      pass = val;
      for(var k in name) {
        Dom.attr(els, k, name[k], pass)
      }
      return undefined
    }
    if(pass && attrFn[name]) {
      return Dom[name](selector, val)
    }
    name = name.toLowerCase();
    if(pass && attrFn[name]) {
      return Dom[name](selector, val)
    }
    name = attrFix[name] || name;
    if(R_BOOLEAN.test(name)) {
      attrNormalizer = boolHook
    }else {
      if(R_INVALID_CHAR.test(name)) {
        attrNormalizer = attrNodeHook
      }else {
        attrNormalizer = attrHooks[name]
      }
    }
    if(val === undefined) {
      if(el && el.nodeType === NodeType.ELEMENT_NODE) {
        if(nodeName(el) === "form") {
          attrNormalizer = attrNodeHook
        }
        if(attrNormalizer && attrNormalizer.get) {
          return attrNormalizer.get(el, name)
        }
        ret = el.getAttribute(name);
        if(ret === "") {
          var attrNode = el.getAttributeNode(name);
          if(!attrNode || !attrNode.specified) {
            return undefined
          }
        }
        return ret === null ? undefined : ret
      }
    }else {
      for(i = els.length - 1;i >= 0;i--) {
        el = els[i];
        if(el && el.nodeType === NodeType.ELEMENT_NODE) {
          if(nodeName(el) === "form") {
            attrNormalizer = attrNodeHook
          }
          if(attrNormalizer && attrNormalizer.set) {
            attrNormalizer.set(el, val, name)
          }else {
            el.setAttribute(name, EMPTY + val)
          }
        }
      }
    }
    return undefined
  }, removeAttr:function(selector, name) {
    name = name.toLowerCase();
    name = attrFix[name] || name;
    var els = Dom.query(selector), propName, el, i;
    for(i = els.length - 1;i >= 0;i--) {
      el = els[i];
      if(el.nodeType === NodeType.ELEMENT_NODE) {
        el.removeAttribute(name);
        if(R_BOOLEAN.test(name) && (propName = propFix[name] || name) in el) {
          el[propName] = false
        }
      }
    }
  }, hasAttr:docElement && !docElement.hasAttribute ? function(selector, name) {
    name = name.toLowerCase();
    var elems = Dom.query(selector), i, el, attrNode;
    for(i = 0;i < elems.length;i++) {
      el = elems[i];
      attrNode = el.getAttributeNode(name);
      if(attrNode && attrNode.specified) {
        return true
      }
    }
    return false
  } : function(selector, name) {
    var elems = Dom.query(selector), i, len = elems.length;
    for(i = 0;i < len;i++) {
      if(elems[i].hasAttribute(name)) {
        return true
      }
    }
    return false
  }, val:function(selector, value) {
    var hook, ret, elem, els, i, val;
    if(value === undefined) {
      elem = Dom.get(selector);
      if(elem) {
        hook = valHooks[nodeName(elem)] || valHooks[elem.type];
        if(hook && "get" in hook && (ret = hook.get(elem, "value")) !== undefined) {
          return ret
        }
        ret = elem.value;
        return typeof ret === "string" ? ret.replace(R_RETURN, "") : ret == null ? "" : ret
      }
      return undefined
    }
    els = Dom.query(selector);
    for(i = els.length - 1;i >= 0;i--) {
      elem = els[i];
      if(elem.nodeType !== 1) {
        return undefined
      }
      val = value;
      if(val == null) {
        val = ""
      }else {
        if(typeof val === "number") {
          val += ""
        }else {
          if(S.isArray(val)) {
            val = S.map(val, toStr)
          }
        }
      }
      hook = valHooks[nodeName(elem)] || valHooks[elem.type];
      if(!hook || !("set" in hook) || hook.set(elem, val, "value") === undefined) {
        elem.value = val
      }
    }
    return undefined
  }, text:function(selector, val) {
    var el, els, i, nodeType;
    if(val === undefined) {
      el = Dom.get(selector);
      return Dom._getText(el)
    }else {
      els = Dom.query(selector);
      for(i = els.length - 1;i >= 0;i--) {
        el = els[i];
        nodeType = el.nodeType;
        if(nodeType === NodeType.ELEMENT_NODE) {
          Dom.cleanData(el.getElementsByTagName("*"));
          if("textContent" in el) {
            el.textContent = val
          }else {
            el.innerText = val
          }
        }else {
          if(nodeType === NodeType.TEXT_NODE || nodeType === NodeType.CDATA_SECTION_NODE) {
            el.nodeValue = val
          }
        }
      }
    }
    return undefined
  }, _getText:function(el) {
    return el.textContent
  }});
  return Dom
});
KISSY.add("dom/base/class", ["./api"], function(S, require) {
  var Dom = require("./api");
  var slice = [].slice, NodeType = Dom.NodeType, RE_SPLIT = /[\.\s]\s*\.?/;
  function strToArray(str) {
    str = S.trim(str || "");
    var arr = str.split(RE_SPLIT), newArr = [], v, l = arr.length, i = 0;
    for(;i < l;i++) {
      if(v = arr[i]) {
        newArr.push(v)
      }
    }
    return newArr
  }
  function batchClassList(method) {
    return function(elem, classNames) {
      var i, l, className, classList = elem.classList, extraArgs = slice.call(arguments, 2);
      for(i = 0, l = classNames.length;i < l;i++) {
        if(className = classNames[i]) {
          classList[method].apply(classList, [className].concat(extraArgs))
        }
      }
    }
  }
  function batchEls(method) {
    return function(selector, className) {
      var classNames = strToArray(className), extraArgs = slice.call(arguments, 2);
      Dom.query(selector).each(function(elem) {
        if(elem.nodeType === NodeType.ELEMENT_NODE) {
          Dom[method].apply(Dom, [elem, classNames].concat(extraArgs))
        }
      })
    }
  }
  S.mix(Dom, {_hasClass:function(elem, classNames) {
    var i, l, className, classList = elem.classList;
    if(classList.length) {
      for(i = 0, l = classNames.length;i < l;i++) {
        className = classNames[i];
        if(className && !classList.contains(className)) {
          return false
        }
      }
      return true
    }
    return false
  }, _addClass:batchClassList("add"), _removeClass:batchClassList("remove"), _toggleClass:batchClassList("toggle"), hasClass:function(selector, className) {
    var ret = false;
    className = strToArray(className);
    Dom.query(selector).each(function(elem) {
      if(elem.nodeType === NodeType.ELEMENT_NODE && Dom._hasClass(elem, className)) {
        ret = true;
        return false
      }
      return undefined
    });
    return ret
  }, replaceClass:function(selector, oldClassName, newClassName) {
    Dom.removeClass(selector, oldClassName);
    Dom.addClass(selector, newClassName)
  }, addClass:batchEls("_addClass"), removeClass:batchEls("_removeClass"), toggleClass:batchEls("_toggleClass")});
  return Dom
});
KISSY.add("dom/base/create", ["./api"], function(S, require) {
  var Dom = require("./api");
  var logger = S.getLogger("s/dom");
  var doc = S.Env.host.document, NodeType = Dom.NodeType, UA = S.UA, ie = UA.ieMode, DIV = "div", PARENT_NODE = "parentNode", DEFAULT_DIV = doc && doc.createElement(DIV), R_XHTML_TAG = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig, RE_TAG = /<([\w:]+)/, R_LEADING_WHITESPACE = /^\s+/, R_TAIL_WHITESPACE = /\s+$/, oldIE = !!(ie && ie < 9), lostLeadingTailWhitespace = oldIE, R_HTML = /<|&#?\w+;/, supportOuterHTML = doc && "outerHTML" in doc.documentElement, RE_SIMPLE_TAG = 
  /^<(\w+)\s*\/?>(?:<\/\1>)?$/;
  function getElementsByTagName(el, tag) {
    return el.getElementsByTagName(tag)
  }
  function getHolderDiv(ownerDoc) {
    var holder = ownerDoc && ownerDoc !== doc ? ownerDoc.createElement(DIV) : DEFAULT_DIV;
    if(holder === DEFAULT_DIV) {
      holder.innerHTML = ""
    }
    return holder
  }
  function defaultCreator(html, ownerDoc) {
    var frag = getHolderDiv(ownerDoc);
    frag.innerHTML = "m<div>" + html + "<" + "/div>";
    return frag.lastChild
  }
  function _empty(node) {
    try {
      node.innerHTML = "";
      return
    }catch(e) {
    }
    for(var c;c = node.lastChild;) {
      _destroy(c, node)
    }
  }
  function _destroy(node, parent) {
    if(parent) {
      if(oldIE && parent.canHaveChildren && "removeNode" in node) {
        if(node.firstChild) {
          _empty(node)
        }
        node.removeNode(false)
      }else {
        parent.removeChild(node)
      }
    }
  }
  S.mix(Dom, {create:function(html, props, ownerDoc, _trim) {
    var ret = null;
    if(!html) {
      return ret
    }
    if(html.nodeType) {
      return Dom.clone(html)
    }
    if(typeof html !== "string") {
      return ret
    }
    if(_trim === undefined) {
      _trim = true
    }
    if(_trim) {
      html = S.trim(html)
    }
    var creators = Dom._creators, holder, whitespaceMatch, context = ownerDoc || doc, m, tag = DIV, k, nodes;
    if(!R_HTML.test(html)) {
      ret = context.createTextNode(html)
    }else {
      if(m = RE_SIMPLE_TAG.exec(html)) {
        ret = context.createElement(m[1])
      }else {
        html = html.replace(R_XHTML_TAG, "<$1><" + "/$2>");
        if((m = RE_TAG.exec(html)) && (k = m[1])) {
          tag = k.toLowerCase()
        }
        holder = (creators[tag] || defaultCreator)(html, context);
        if(lostLeadingTailWhitespace && (whitespaceMatch = html.match(R_LEADING_WHITESPACE))) {
          holder.insertBefore(context.createTextNode(whitespaceMatch[0]), holder.firstChild)
        }
        if(lostLeadingTailWhitespace && /\S/.test(html) && (whitespaceMatch = html.match(R_TAIL_WHITESPACE))) {
          holder.appendChild(context.createTextNode(whitespaceMatch[0]))
        }
        nodes = holder.childNodes;
        if(nodes.length === 1) {
          ret = nodes[0][PARENT_NODE].removeChild(nodes[0])
        }else {
          if(nodes.length) {
            ret = nodeListToFragment(nodes)
          }else {
            S.error(html + " : create node error")
          }
        }
      }
    }
    return attachProps(ret, props)
  }, _fixCloneAttributes:function(src, dest) {
    if(Dom.nodeName(src) === "textarea") {
      dest.defaultValue = src.defaultValue;
      dest.value = src.value
    }
  }, _creators:{div:defaultCreator}, _defaultCreator:defaultCreator, html:function(selector, htmlString, loadScripts) {
    var els = Dom.query(selector), el = els[0], success = false, valNode, i, elem;
    if(!el) {
      return null
    }
    if(htmlString === undefined) {
      if(el.nodeType === NodeType.ELEMENT_NODE) {
        return el.innerHTML
      }else {
        if(el.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
          var holder = getHolderDiv(el.ownerDocument);
          holder.appendChild(el);
          return holder.innerHTML
        }else {
          return null
        }
      }
    }else {
      htmlString += "";
      if(!htmlString.match(/<(?:script|style|link)/i) && (!lostLeadingTailWhitespace || !htmlString.match(R_LEADING_WHITESPACE)) && !creatorsMap[(htmlString.match(RE_TAG) || ["", ""])[1].toLowerCase()]) {
        try {
          for(i = els.length - 1;i >= 0;i--) {
            elem = els[i];
            if(elem.nodeType === NodeType.ELEMENT_NODE) {
              Dom.cleanData(getElementsByTagName(elem, "*"));
              elem.innerHTML = htmlString
            }
          }
          success = true
        }catch(e) {
        }
      }
      if(!success) {
        valNode = Dom.create(htmlString, 0, el.ownerDocument, 0);
        Dom.empty(els);
        Dom.append(valNode, els, loadScripts)
      }
    }
    return undefined
  }, outerHtml:function(selector, htmlString, loadScripts) {
    var els = Dom.query(selector), holder, i, valNode, length = els.length, el = els[0];
    if(!el) {
      return null
    }
    if(htmlString === undefined) {
      if(supportOuterHTML && el.nodeType !== Dom.DOCUMENT_FRAGMENT_NODE) {
        return el.outerHTML
      }else {
        holder = getHolderDiv(el.ownerDocument);
        holder.appendChild(Dom.clone(el, true));
        return holder.innerHTML
      }
    }else {
      htmlString += "";
      if(!htmlString.match(/<(?:script|style|link)/i) && supportOuterHTML) {
        for(i = length - 1;i >= 0;i--) {
          el = els[i];
          if(el.nodeType === NodeType.ELEMENT_NODE) {
            Dom.cleanData(el, 1);
            el.outerHTML = htmlString
          }
        }
      }else {
        valNode = Dom.create(htmlString, 0, el.ownerDocument, 0);
        Dom.insertBefore(valNode, els, loadScripts);
        Dom.remove(els)
      }
    }
    return undefined
  }, remove:function(selector, keepData) {
    var el, els = Dom.query(selector), all, DOMEvent = S.require("event/dom"), i;
    for(i = els.length - 1;i >= 0;i--) {
      el = els[i];
      if(!keepData && el.nodeType === NodeType.ELEMENT_NODE) {
        all = S.makeArray(getElementsByTagName(el, "*"));
        all.push(el);
        Dom.removeData(all);
        if(DOMEvent) {
          DOMEvent.detach(all)
        }
      }
      _destroy(el, el.parentNode)
    }
  }, clone:function(selector, deep, withDataAndEvent, deepWithDataAndEvent) {
    if(typeof deep === "object") {
      deepWithDataAndEvent = deep.deepWithDataAndEvent;
      withDataAndEvent = deep.withDataAndEvent;
      deep = deep.deep
    }
    var elem = Dom.get(selector), clone, _fixCloneAttributes = Dom._fixCloneAttributes, elemNodeType;
    if(!elem) {
      return null
    }
    elemNodeType = elem.nodeType;
    clone = elem.cloneNode(deep);
    if(elemNodeType === NodeType.ELEMENT_NODE || elemNodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
      if(_fixCloneAttributes && elemNodeType === NodeType.ELEMENT_NODE) {
        _fixCloneAttributes(elem, clone)
      }
      if(deep && _fixCloneAttributes) {
        processAll(_fixCloneAttributes, elem, clone)
      }
    }
    if(withDataAndEvent) {
      cloneWithDataAndEvent(elem, clone);
      if(deep && deepWithDataAndEvent) {
        processAll(cloneWithDataAndEvent, elem, clone)
      }
    }
    return clone
  }, empty:function(selector) {
    var els = Dom.query(selector), el, i;
    for(i = els.length - 1;i >= 0;i--) {
      el = els[i];
      Dom.remove(el.childNodes)
    }
  }, _nodeListToFragment:nodeListToFragment});
  Dom.outerHTML = Dom.outerHtml;
  function processAll(fn, elem, clone) {
    var elemNodeType = elem.nodeType;
    if(elemNodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
      var eCs = elem.childNodes, cloneCs = clone.childNodes, fIndex = 0;
      while(eCs[fIndex]) {
        if(cloneCs[fIndex]) {
          processAll(fn, eCs[fIndex], cloneCs[fIndex])
        }
        fIndex++
      }
    }else {
      if(elemNodeType === NodeType.ELEMENT_NODE) {
        var elemChildren = getElementsByTagName(elem, "*"), cloneChildren = getElementsByTagName(clone, "*"), cIndex = 0;
        while(elemChildren[cIndex]) {
          if(cloneChildren[cIndex]) {
            fn(elemChildren[cIndex], cloneChildren[cIndex])
          }
          cIndex++
        }
      }
    }
  }
  function cloneWithDataAndEvent(src, dest) {
    var DOMEvent = S.require("event/dom"), srcData, d;
    if(dest.nodeType === NodeType.ELEMENT_NODE && !Dom.hasData(src)) {
      return
    }
    srcData = Dom.data(src);
    for(d in srcData) {
      Dom.data(dest, d, srcData[d])
    }
    if(DOMEvent) {
      DOMEvent.clone(src, dest)
    }
  }
  function attachProps(elem, props) {
    if(S.isPlainObject(props)) {
      if(elem.nodeType === NodeType.ELEMENT_NODE) {
        Dom.attr(elem, props, true)
      }else {
        if(elem.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
          Dom.attr(elem.childNodes, props, true)
        }
      }
    }
    return elem
  }
  function nodeListToFragment(nodes) {
    var ret = null, i, ownerDoc, len;
    if(nodes && (nodes.push || nodes.item) && nodes[0]) {
      ownerDoc = nodes[0].ownerDocument;
      ret = ownerDoc.createDocumentFragment();
      nodes = S.makeArray(nodes);
      for(i = 0, len = nodes.length;i < len;i++) {
        ret.appendChild(nodes[i])
      }
    }else {
      logger.error("Unable to convert " + nodes + " to fragment.")
    }
    return ret
  }
  var creators = Dom._creators, create = Dom.create, creatorsMap = {area:"map", thead:"table", td:"tr", th:"tr", tr:"tbody", tbody:"table", tfoot:"table", caption:"table", colgroup:"table", col:"colgroup", legend:"fieldset"}, p;
  for(p in creatorsMap) {
    (function(tag) {
      creators[p] = function(html, ownerDoc) {
        return create("<" + tag + ">" + html + "<" + "/" + tag + ">", undefined, ownerDoc)
      }
    })(creatorsMap[p])
  }
  creators.option = creators.optgroup = function(html, ownerDoc) {
    return create('<select multiple="multiple">' + html + "</select>", undefined, ownerDoc)
  };
  return Dom
});
KISSY.add("dom/base/data", ["./api"], function(S, require) {
  var Dom = require("./api");
  var win = S.Env.host, EXPANDO = "_ks_data_" + S.now(), dataCache = {}, winDataCache = {}, noData = {applet:1, object:1, embed:1};
  var commonOps = {hasData:function(cache, name) {
    if(cache) {
      if(name !== undefined) {
        if(name in cache) {
          return true
        }
      }else {
        if(!S.isEmptyObject(cache)) {
          return true
        }
      }
    }
    return false
  }};
  var objectOps = {hasData:function(ob, name) {
    if(ob == win) {
      return objectOps.hasData(winDataCache, name)
    }
    var thisCache = ob[EXPANDO];
    return commonOps.hasData(thisCache, name)
  }, data:function(ob, name, value) {
    if(ob == win) {
      return objectOps.data(winDataCache, name, value)
    }
    var cache = ob[EXPANDO];
    if(value !== undefined) {
      cache = ob[EXPANDO] = ob[EXPANDO] || {};
      cache[name] = value
    }else {
      if(name !== undefined) {
        return cache && cache[name]
      }else {
        cache = ob[EXPANDO] = ob[EXPANDO] || {};
        return cache
      }
    }
  }, removeData:function(ob, name) {
    if(ob == win) {
      return objectOps.removeData(winDataCache, name)
    }
    var cache = ob[EXPANDO];
    if(name !== undefined) {
      delete cache[name];
      if(S.isEmptyObject(cache)) {
        objectOps.removeData(ob)
      }
    }else {
      try {
        delete ob[EXPANDO]
      }catch(e) {
        ob[EXPANDO] = undefined
      }
    }
  }};
  var domOps = {hasData:function(elem, name) {
    var key = elem[EXPANDO];
    if(!key) {
      return false
    }
    var thisCache = dataCache[key];
    return commonOps.hasData(thisCache, name)
  }, data:function(elem, name, value) {
    if(noData[elem.nodeName.toLowerCase()]) {
      return undefined
    }
    var key = elem[EXPANDO], cache;
    if(!key) {
      if(name !== undefined && value === undefined) {
        return undefined
      }
      key = elem[EXPANDO] = S.guid()
    }
    cache = dataCache[key];
    if(value !== undefined) {
      cache = dataCache[key] = dataCache[key] || {};
      cache[name] = value
    }else {
      if(name !== undefined) {
        return cache && cache[name]
      }else {
        cache = dataCache[key] = dataCache[key] || {};
        return cache
      }
    }
  }, removeData:function(elem, name) {
    var key = elem[EXPANDO], cache;
    if(!key) {
      return
    }
    cache = dataCache[key];
    if(name !== undefined) {
      delete cache[name];
      if(S.isEmptyObject(cache)) {
        domOps.removeData(elem)
      }
    }else {
      delete dataCache[key];
      try {
        delete elem[EXPANDO]
      }catch(e) {
        elem[EXPANDO] = undefined
      }
      if(elem.removeAttribute) {
        elem.removeAttribute(EXPANDO)
      }
    }
  }};
  S.mix(Dom, {__EXPANDO:EXPANDO, hasData:function(selector, name) {
    var ret = false, elems = Dom.query(selector);
    for(var i = 0;i < elems.length;i++) {
      var elem = elems[i];
      if(elem.nodeType) {
        ret = domOps.hasData(elem, name)
      }else {
        ret = objectOps.hasData(elem, name)
      }
      if(ret) {
        return ret
      }
    }
    return ret
  }, data:function(selector, name, data) {
    var elems = Dom.query(selector), elem = elems[0];
    if(S.isPlainObject(name)) {
      for(var k in name) {
        Dom.data(elems, k, name[k])
      }
      return undefined
    }
    if(data === undefined) {
      if(elem) {
        if(elem.nodeType) {
          return domOps.data(elem, name)
        }else {
          return objectOps.data(elem, name)
        }
      }
    }else {
      for(var i = elems.length - 1;i >= 0;i--) {
        elem = elems[i];
        if(elem.nodeType) {
          domOps.data(elem, name, data)
        }else {
          objectOps.data(elem, name, data)
        }
      }
    }
    return undefined
  }, removeData:function(selector, name) {
    var els = Dom.query(selector), elem, i;
    for(i = els.length - 1;i >= 0;i--) {
      elem = els[i];
      if(elem.nodeType) {
        domOps.removeData(elem, name)
      }else {
        objectOps.removeData(elem, name)
      }
    }
  }, cleanData:function(selector, deep) {
    var els = Dom.query(selector), elem, i;
    var DOMEvent = S.require("event/dom");
    for(i = els.length - 1;i >= 0;i--) {
      elem = els[i];
      if(elem.nodeType) {
        var descendants = deep && S.makeArray(elem.getElementsByTagName("*")) || [];
        descendants.push(elem);
        for(var j = 0, len = descendants.length;j < len;j++) {
          domOps.removeData(descendants[j])
        }
        if(DOMEvent) {
          DOMEvent.detach(descendants)
        }
      }else {
        objectOps.removeData(elem)
      }
    }
  }});
  return Dom
});
KISSY.add("dom/base/insertion", ["./api"], function(S, require) {
  var Dom = require("./api");
  var PARENT_NODE = "parentNode", NodeType = Dom.NodeType, RE_FORM_EL = /^(?:button|input|object|select|textarea)$/i, getNodeName = Dom.nodeName, makeArray = S.makeArray, splice = [].splice, NEXT_SIBLING = "nextSibling", R_SCRIPT_TYPE = /\/(java|ecma)script/i;
  function isJs(el) {
    return!el.type || R_SCRIPT_TYPE.test(el.type)
  }
  function filterScripts(nodes, scripts) {
    var ret = [], i, el, nodeName;
    for(i = 0;nodes[i];i++) {
      el = nodes[i];
      nodeName = getNodeName(el);
      if(el.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
        ret.push.apply(ret, filterScripts(makeArray(el.childNodes), scripts))
      }else {
        if(nodeName === "script" && isJs(el)) {
          if(el.parentNode) {
            el.parentNode.removeChild(el)
          }
          if(scripts) {
            scripts.push(el)
          }
        }else {
          if(el.nodeType === NodeType.ELEMENT_NODE && !RE_FORM_EL.test(nodeName)) {
            var tmp = [], s, j, ss = el.getElementsByTagName("script");
            for(j = 0;j < ss.length;j++) {
              s = ss[j];
              if(isJs(s)) {
                tmp.push(s)
              }
            }
            splice.apply(nodes, [i + 1, 0].concat(tmp))
          }
          ret.push(el)
        }
      }
    }
    return ret
  }
  function evalScript(el) {
    if(el.src) {
      S.getScript(el.src)
    }else {
      var code = S.trim(el.text || el.textContent || el.innerHTML || "");
      if(code) {
        S.globalEval(code)
      }
    }
  }
  function insertion(newNodes, refNodes, fn, scripts) {
    newNodes = Dom.query(newNodes);
    if(scripts) {
      scripts = []
    }
    newNodes = filterScripts(newNodes, scripts);
    if(Dom._fixInsertionChecked) {
      Dom._fixInsertionChecked(newNodes)
    }
    refNodes = Dom.query(refNodes);
    var newNodesLength = newNodes.length, newNode, i, refNode, node, clonedNode, refNodesLength = refNodes.length;
    if(!newNodesLength && (!scripts || !scripts.length) || !refNodesLength) {
      return
    }
    newNode = Dom._nodeListToFragment(newNodes);
    if(refNodesLength > 1) {
      clonedNode = Dom.clone(newNode, true);
      refNodes = S.makeArray(refNodes)
    }
    for(i = 0;i < refNodesLength;i++) {
      refNode = refNodes[i];
      if(newNode) {
        node = i > 0 ? Dom.clone(clonedNode, true) : newNode;
        fn(node, refNode)
      }
      if(scripts && scripts.length) {
        S.each(scripts, evalScript)
      }
    }
  }
  S.mix(Dom, {_fixInsertionChecked:null, insertBefore:function(newNodes, refNodes, loadScripts) {
    insertion(newNodes, refNodes, function(newNode, refNode) {
      if(refNode[PARENT_NODE]) {
        refNode[PARENT_NODE].insertBefore(newNode, refNode)
      }
    }, loadScripts)
  }, insertAfter:function(newNodes, refNodes, loadScripts) {
    insertion(newNodes, refNodes, function(newNode, refNode) {
      if(refNode[PARENT_NODE]) {
        refNode[PARENT_NODE].insertBefore(newNode, refNode[NEXT_SIBLING])
      }
    }, loadScripts)
  }, appendTo:function(newNodes, parents, loadScripts) {
    insertion(newNodes, parents, function(newNode, parent) {
      parent.appendChild(newNode)
    }, loadScripts)
  }, prependTo:function(newNodes, parents, loadScripts) {
    insertion(newNodes, parents, function(newNode, parent) {
      parent.insertBefore(newNode, parent.firstChild)
    }, loadScripts)
  }, wrapAll:function(wrappedNodes, wrapperNode) {
    wrapperNode = Dom.clone(Dom.get(wrapperNode), true);
    wrappedNodes = Dom.query(wrappedNodes);
    if(wrappedNodes[0].parentNode) {
      Dom.insertBefore(wrapperNode, wrappedNodes[0])
    }
    var c;
    while((c = wrapperNode.firstChild) && c.nodeType === 1) {
      wrapperNode = c
    }
    Dom.appendTo(wrappedNodes, wrapperNode)
  }, wrap:function(wrappedNodes, wrapperNode) {
    wrappedNodes = Dom.query(wrappedNodes);
    wrapperNode = Dom.get(wrapperNode);
    S.each(wrappedNodes, function(w) {
      Dom.wrapAll(w, wrapperNode)
    })
  }, wrapInner:function(wrappedNodes, wrapperNode) {
    wrappedNodes = Dom.query(wrappedNodes);
    wrapperNode = Dom.get(wrapperNode);
    S.each(wrappedNodes, function(w) {
      var contents = w.childNodes;
      if(contents.length) {
        Dom.wrapAll(contents, wrapperNode)
      }else {
        w.appendChild(wrapperNode)
      }
    })
  }, unwrap:function(wrappedNodes) {
    wrappedNodes = Dom.query(wrappedNodes);
    S.each(wrappedNodes, function(w) {
      var p = w.parentNode;
      Dom.replaceWith(p, p.childNodes)
    })
  }, replaceWith:function(selector, newNodes) {
    var nodes = Dom.query(selector);
    newNodes = Dom.query(newNodes);
    Dom.remove(newNodes, true);
    Dom.insertBefore(newNodes, nodes);
    Dom.remove(nodes)
  }});
  S.each({prepend:"prependTo", append:"appendTo", before:"insertBefore", after:"insertAfter"}, function(value, key) {
    Dom[key] = Dom[value]
  });
  return Dom
});
KISSY.add("dom/base/offset", ["./api"], function(S, require) {
  var Dom = require("./api");
  var win = S.Env.host, UA = S.UA, doc = win.document, NodeType = Dom.NodeType, docElem = doc && doc.documentElement, getWindow = Dom.getWindow, CSS1Compat = "CSS1Compat", compatMode = "compatMode", MAX = Math.max, POSITION = "position", RELATIVE = "relative", DOCUMENT = "document", BODY = "body", DOC_ELEMENT = "documentElement", VIEWPORT = "viewport", SCROLL = "scroll", CLIENT = "client", LEFT = "left", TOP = "top", SCROLL_LEFT = SCROLL + "Left", SCROLL_TOP = SCROLL + "Top";
  S.mix(Dom, {offset:function(selector, coordinates, relativeWin) {
    var elem;
    if(coordinates === undefined) {
      elem = Dom.get(selector);
      var ret;
      if(elem) {
        ret = getOffset(elem, relativeWin)
      }
      return ret
    }
    var els = Dom.query(selector), i;
    for(i = els.length - 1;i >= 0;i--) {
      elem = els[i];
      setOffset(elem, coordinates)
    }
    return undefined
  }, scrollIntoView:function(selector, container, alignWithTop, allowHorizontalScroll) {
    var elem, onlyScrollIfNeeded;
    if(!(elem = Dom.get(selector))) {
      return
    }
    if(container) {
      container = Dom.get(container)
    }
    if(!container) {
      container = elem.ownerDocument
    }
    if(container.nodeType === NodeType.DOCUMENT_NODE) {
      container = getWindow(container)
    }
    if(S.isPlainObject(alignWithTop)) {
      allowHorizontalScroll = alignWithTop.allowHorizontalScroll;
      onlyScrollIfNeeded = alignWithTop.onlyScrollIfNeeded;
      alignWithTop = alignWithTop.alignWithTop
    }
    allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;
    var isWin = S.isWindow(container), elemOffset = Dom.offset(elem), eh = Dom.outerHeight(elem), ew = Dom.outerWidth(elem), containerOffset, ch, cw, containerScroll, diffTop, diffBottom, win, winScroll, ww, wh;
    if(isWin) {
      win = container;
      wh = Dom.height(win);
      ww = Dom.width(win);
      winScroll = {left:Dom.scrollLeft(win), top:Dom.scrollTop(win)};
      diffTop = {left:elemOffset[LEFT] - winScroll[LEFT], top:elemOffset[TOP] - winScroll[TOP]};
      diffBottom = {left:elemOffset[LEFT] + ew - (winScroll[LEFT] + ww), top:elemOffset[TOP] + eh - (winScroll[TOP] + wh)};
      containerScroll = winScroll
    }else {
      containerOffset = Dom.offset(container);
      ch = container.clientHeight;
      cw = container.clientWidth;
      containerScroll = {left:Dom.scrollLeft(container), top:Dom.scrollTop(container)};
      diffTop = {left:elemOffset[LEFT] - (containerOffset[LEFT] + (parseFloat(Dom.css(container, "borderLeftWidth")) || 0)), top:elemOffset[TOP] - (containerOffset[TOP] + (parseFloat(Dom.css(container, "borderTopWidth")) || 0))};
      diffBottom = {left:elemOffset[LEFT] + ew - (containerOffset[LEFT] + cw + (parseFloat(Dom.css(container, "borderRightWidth")) || 0)), top:elemOffset[TOP] + eh - (containerOffset[TOP] + ch + (parseFloat(Dom.css(container, "borderBottomWidth")) || 0))}
    }
    if(onlyScrollIfNeeded) {
      if(diffTop.top < 0 || diffBottom.top > 0) {
        if(alignWithTop === true) {
          Dom.scrollTop(container, containerScroll.top + diffTop.top)
        }else {
          if(alignWithTop === false) {
            Dom.scrollTop(container, containerScroll.top + diffBottom.top)
          }else {
            if(diffTop.top < 0) {
              Dom.scrollTop(container, containerScroll.top + diffTop.top)
            }else {
              Dom.scrollTop(container, containerScroll.top + diffBottom.top)
            }
          }
        }
      }
    }else {
      alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
      if(alignWithTop) {
        Dom.scrollTop(container, containerScroll.top + diffTop.top)
      }else {
        Dom.scrollTop(container, containerScroll.top + diffBottom.top)
      }
    }
    if(allowHorizontalScroll) {
      if(onlyScrollIfNeeded) {
        if(diffTop.left < 0 || diffBottom.left > 0) {
          if(alignWithTop === true) {
            Dom.scrollLeft(container, containerScroll.left + diffTop.left)
          }else {
            if(alignWithTop === false) {
              Dom.scrollLeft(container, containerScroll.left + diffBottom.left)
            }else {
              if(diffTop.left < 0) {
                Dom.scrollLeft(container, containerScroll.left + diffTop.left)
              }else {
                Dom.scrollLeft(container, containerScroll.left + diffBottom.left)
              }
            }
          }
        }
      }else {
        alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
        if(alignWithTop) {
          Dom.scrollLeft(container, containerScroll.left + diffTop.left)
        }else {
          Dom.scrollLeft(container, containerScroll.left + diffBottom.left)
        }
      }
    }
  }, docWidth:0, docHeight:0, viewportHeight:0, viewportWidth:0, scrollTop:0, scrollLeft:0});
  S.each(["Left", "Top"], function(name, i) {
    var method = SCROLL + name;
    Dom[method] = function(elem, v) {
      if(typeof elem === "number") {
        return arguments.callee(win, elem)
      }
      elem = Dom.get(elem);
      var ret, left, top, w, d;
      if(elem && elem.nodeType === NodeType.ELEMENT_NODE) {
        if(v !== undefined) {
          elem[method] = parseFloat(v)
        }else {
          ret = elem[method]
        }
      }else {
        w = getWindow(elem);
        if(v !== undefined) {
          v = parseFloat(v);
          left = name === "Left" ? v : Dom.scrollLeft(w);
          top = name === "Top" ? v : Dom.scrollTop(w);
          w.scrollTo(left, top)
        }else {
          ret = w["page" + (i ? "Y" : "X") + "Offset"];
          if(typeof ret !== "number") {
            d = w[DOCUMENT];
            ret = d[DOC_ELEMENT][method];
            if(typeof ret !== "number") {
              ret = d[BODY][method]
            }
          }
        }
      }
      return ret
    }
  });
  S.each(["Width", "Height"], function(name) {
    Dom["doc" + name] = function(refWin) {
      refWin = Dom.get(refWin);
      var d = Dom.getDocument(refWin);
      return MAX(d[DOC_ELEMENT][SCROLL + name], d[BODY][SCROLL + name], Dom[VIEWPORT + name](d))
    };
    Dom[VIEWPORT + name] = function(refWin) {
      refWin = Dom.get(refWin);
      var win = getWindow(refWin);
      var ret = win["inner" + name];
      if(UA.mobile && ret) {
        return ret
      }
      var prop = CLIENT + name, doc = win[DOCUMENT], body = doc[BODY], documentElement = doc[DOC_ELEMENT], documentElementProp = documentElement[prop];
      return doc[compatMode] === CSS1Compat && documentElementProp || body && body[prop] || documentElementProp
    }
  });
  function getClientPosition(elem) {
    var box, x, y, doc = elem.ownerDocument, body = doc.body;
    if(!elem.getBoundingClientRect) {
      return{left:0, top:0}
    }
    box = elem.getBoundingClientRect();
    x = box[LEFT];
    y = box[TOP];
    x -= docElem.clientLeft || body.clientLeft || 0;
    y -= docElem.clientTop || body.clientTop || 0;
    return{left:x, top:y}
  }
  function getPageOffset(el) {
    var pos = getClientPosition(el), w = getWindow(el);
    pos.left += Dom[SCROLL_LEFT](w);
    pos.top += Dom[SCROLL_TOP](w);
    return pos
  }
  function getOffset(el, relativeWin) {
    var position = {left:0, top:0}, currentWin = getWindow(el), offset, currentEl = el;
    relativeWin = relativeWin || currentWin;
    do {
      offset = currentWin == relativeWin ? getPageOffset(currentEl) : getClientPosition(currentEl);
      position.left += offset.left;
      position.top += offset.top
    }while(currentWin && currentWin != relativeWin && (currentEl = currentWin.frameElement) && (currentWin = currentWin.parent));
    return position
  }
  function setOffset(elem, offset) {
    if(Dom.css(elem, POSITION) === "static") {
      elem.style[POSITION] = RELATIVE
    }
    var old = getOffset(elem), ret = {}, current, key;
    for(key in offset) {
      current = parseFloat(Dom.css(elem, key)) || 0;
      ret[key] = current + offset[key] - old[key]
    }
    Dom.css(elem, ret)
  }
  return Dom
});
KISSY.add("dom/base/style", ["./api"], function(S, require) {
  var Dom = require("./api");
  var logger = S.getLogger("s/dom");
  var globalWindow = S.Env.host, UA = S.UA, Features = S.Features, getNodeName = Dom.nodeName, doc = globalWindow.document, RE_MARGIN = /^margin/, WIDTH = "width", HEIGHT = "height", DISPLAY = "display", OLD_DISPLAY = DISPLAY + S.now(), NONE = "none", cssNumber = {fillOpacity:1, fontWeight:1, lineHeight:1, opacity:1, orphans:1, widows:1, zIndex:1, zoom:1}, rmsPrefix = /^-ms-/, EMPTY = "", DEFAULT_UNIT = "px", NO_PX_REG = /\d(?!px)[a-z%]+$/i, cssHooks = {}, cssProps = {"float":"cssFloat"}, defaultDisplay = 
  {}, RE_DASH = /-([a-z])/ig;
  var VENDORS = ["", "Webkit", "Moz", "O", "ms"];
  var documentElementStyle = doc && doc.documentElement.style || {};
  var userSelectProperty;
  S.each(VENDORS, function(val) {
    var userSelect = val ? val + "UserSelect" : "userSelect";
    if(userSelectProperty === undefined && userSelect in documentElementStyle) {
      userSelectProperty = userSelect
    }
  });
  if(Features.isTransformSupported()) {
    var transform;
    transform = cssProps.transform = Features.getTransformProperty();
    cssProps.transformOrigin = transform + "Origin"
  }
  if(Features.isTransitionSupported()) {
    cssProps.transition = Features.getTransitionProperty()
  }
  function upperCase() {
    return arguments[1].toUpperCase()
  }
  function camelCase(name) {
    return name.replace(rmsPrefix, "ms-").replace(RE_DASH, upperCase)
  }
  function getDefaultDisplay(tagName) {
    var body, oldDisplay = defaultDisplay[tagName], elem;
    if(!defaultDisplay[tagName]) {
      body = doc.body || doc.documentElement;
      elem = doc.createElement(tagName);
      Dom.prepend(elem, body);
      oldDisplay = Dom.css(elem, "display");
      body.removeChild(elem);
      defaultDisplay[tagName] = oldDisplay
    }
    return oldDisplay
  }
  S.mix(Dom, {_camelCase:camelCase, _cssHooks:cssHooks, _cssProps:cssProps, _getComputedStyle:function(elem, name) {
    var val = "", computedStyle, width, minWidth, maxWidth, style, d = elem.ownerDocument;
    name = cssProps[name] || name;
    if(computedStyle = d.defaultView.getComputedStyle(elem, null)) {
      val = computedStyle.getPropertyValue(name) || computedStyle[name]
    }
    if(val === "" && !Dom.contains(d, elem)) {
      val = elem.style[name]
    }
    if(Dom._RE_NUM_NO_PX.test(val) && RE_MARGIN.test(name)) {
      style = elem.style;
      width = style.width;
      minWidth = style.minWidth;
      maxWidth = style.maxWidth;
      style.minWidth = style.maxWidth = style.width = val;
      val = computedStyle.width;
      style.width = width;
      style.minWidth = minWidth;
      style.maxWidth = maxWidth
    }
    return val
  }, style:function(selector, name, val) {
    var els = Dom.query(selector), k, ret, elem = els[0], i;
    if(S.isPlainObject(name)) {
      for(k in name) {
        for(i = els.length - 1;i >= 0;i--) {
          style(els[i], k, name[k])
        }
      }
      return undefined
    }
    if(val === undefined) {
      ret = "";
      if(elem) {
        ret = style(elem, name, val)
      }
      return ret
    }else {
      for(i = els.length - 1;i >= 0;i--) {
        style(els[i], name, val)
      }
    }
    return undefined
  }, css:function(selector, name, val) {
    var els = Dom.query(selector), elem = els[0], k, hook, ret, i;
    if(S.isPlainObject(name)) {
      for(k in name) {
        for(i = els.length - 1;i >= 0;i--) {
          style(els[i], k, name[k])
        }
      }
      return undefined
    }
    name = camelCase(name);
    hook = cssHooks[name];
    if(val === undefined) {
      ret = "";
      if(elem) {
        if(!(hook && "get" in hook && (ret = hook.get(elem, true)) !== undefined)) {
          ret = Dom._getComputedStyle(elem, name)
        }
      }
      return typeof ret === "undefined" ? "" : ret
    }else {
      for(i = els.length - 1;i >= 0;i--) {
        style(els[i], name, val)
      }
    }
    return undefined
  }, show:function(selector) {
    var els = Dom.query(selector), tagName, old, elem, i;
    for(i = els.length - 1;i >= 0;i--) {
      elem = els[i];
      elem.style[DISPLAY] = Dom.data(elem, OLD_DISPLAY) || EMPTY;
      if(Dom.css(elem, DISPLAY) === NONE) {
        tagName = elem.tagName.toLowerCase();
        old = getDefaultDisplay(tagName);
        Dom.data(elem, OLD_DISPLAY, old);
        elem.style[DISPLAY] = old
      }
    }
  }, hide:function(selector) {
    var els = Dom.query(selector), elem, i;
    for(i = els.length - 1;i >= 0;i--) {
      elem = els[i];
      var style = elem.style, old = style[DISPLAY];
      if(old !== NONE) {
        if(old) {
          Dom.data(elem, OLD_DISPLAY, old)
        }
        style[DISPLAY] = NONE
      }
    }
  }, toggle:function(selector) {
    var els = Dom.query(selector), elem, i;
    for(i = els.length - 1;i >= 0;i--) {
      elem = els[i];
      if(Dom.css(elem, DISPLAY) === NONE) {
        Dom.show(elem)
      }else {
        Dom.hide(elem)
      }
    }
  }, addStyleSheet:function(refWin, cssText, id) {
    if(typeof refWin === "string") {
      id = cssText;
      cssText = refWin;
      refWin = globalWindow
    }
    var doc = Dom.getDocument(refWin), elem;
    if(id && (id = id.replace("#", EMPTY))) {
      elem = Dom.get("#" + id, doc)
    }
    if(elem) {
      return
    }
    elem = Dom.create("<style>", {id:id}, doc);
    Dom.get("head", doc).appendChild(elem);
    if(elem.styleSheet) {
      elem.styleSheet.cssText = cssText
    }else {
      elem.appendChild(doc.createTextNode(cssText))
    }
  }, unselectable:function(selector) {
    var _els = Dom.query(selector), elem, j, e, i = 0, excludes, style, els;
    for(j = _els.length - 1;j >= 0;j--) {
      elem = _els[j];
      style = elem.style;
      if(userSelectProperty !== undefined) {
        style[userSelectProperty] = "none"
      }else {
        if(UA.ie) {
          els = elem.getElementsByTagName("*");
          elem.setAttribute("unselectable", "on");
          excludes = ["iframe", "textarea", "input", "select"];
          while(e = els[i++]) {
            if(!S.inArray(getNodeName(e), excludes)) {
              e.setAttribute("unselectable", "on")
            }
          }
        }
      }
    }
  }, innerWidth:0, innerHeight:0, outerWidth:0, outerHeight:0, width:0, height:0});
  S.each([WIDTH, HEIGHT], function(name) {
    Dom["inner" + S.ucfirst(name)] = function(selector) {
      var el = Dom.get(selector);
      return el && getWHIgnoreDisplay(el, name, "padding")
    };
    Dom["outer" + S.ucfirst(name)] = function(selector, includeMargin) {
      var el = Dom.get(selector);
      return el && getWHIgnoreDisplay(el, name, includeMargin ? "margin" : "border")
    };
    Dom[name] = function(selector, val) {
      var ret = Dom.css(selector, name, val);
      if(ret) {
        ret = parseFloat(ret)
      }
      return ret
    };
    cssHooks[name] = {get:function(elem, computed) {
      var val;
      if(computed) {
        val = getWHIgnoreDisplay(elem, name) + "px"
      }
      return val
    }}
  });
  var cssShow = {position:"absolute", visibility:"hidden", display:"block"};
  S.each(["left", "top"], function(name) {
    cssHooks[name] = {get:function(el, computed) {
      var val, isAutoPosition, position;
      if(computed) {
        position = Dom.css(el, "position");
        if(position === "static") {
          return"auto"
        }
        val = Dom._getComputedStyle(el, name);
        isAutoPosition = val === "auto";
        if(isAutoPosition && position === "relative") {
          return"0px"
        }
        if(isAutoPosition || NO_PX_REG.test(val)) {
          val = getPosition(el)[name] + "px"
        }
      }
      return val
    }}
  });
  function swap(elem, options, callback) {
    var old = {}, style = elem.style, name;
    for(name in options) {
      old[name] = style[name];
      style[name] = options[name]
    }
    callback.call(elem);
    for(name in options) {
      style[name] = old[name]
    }
  }
  function style(elem, name, val) {
    var elStyle, ret, hook;
    if(elem.nodeType === 3 || elem.nodeType === 8 || !(elStyle = elem.style)) {
      return undefined
    }
    name = camelCase(name);
    hook = cssHooks[name];
    name = cssProps[name] || name;
    if(val !== undefined) {
      if(val === null || val === EMPTY) {
        val = EMPTY
      }else {
        if(!isNaN(Number(val)) && !cssNumber[name]) {
          val += DEFAULT_UNIT
        }
      }
      if(hook && hook.set) {
        val = hook.set(elem, val)
      }
      if(val !== undefined) {
        try {
          elStyle[name] = val
        }catch(e) {
          logger.warn("css set error:" + e)
        }
        if(val === EMPTY && elStyle.removeAttribute) {
          elStyle.removeAttribute(name)
        }
      }
      if(!elStyle.cssText) {
        if(UA.webkit) {
          elStyle = elem.outerHTML
        }
        elem.removeAttribute("style")
      }
      return undefined
    }else {
      if(!(hook && "get" in hook && (ret = hook.get(elem, false)) !== undefined)) {
        ret = elStyle[name]
      }
      return ret === undefined ? "" : ret
    }
  }
  function getWHIgnoreDisplay(elem) {
    var val, args = arguments;
    if(elem.offsetWidth !== 0) {
      val = getWH.apply(undefined, args)
    }else {
      swap(elem, cssShow, function() {
        val = getWH.apply(undefined, args)
      })
    }
    return val
  }
  function getWH(elem, name, extra) {
    if(S.isWindow(elem)) {
      return name === WIDTH ? Dom.viewportWidth(elem) : Dom.viewportHeight(elem)
    }else {
      if(elem.nodeType === 9) {
        return name === WIDTH ? Dom.docWidth(elem) : Dom.docHeight(elem)
      }
    }
    var which = name === WIDTH ? ["Left", "Right"] : ["Top", "Bottom"], val = name === WIDTH ? elem.offsetWidth : elem.offsetHeight;
    if(val > 0) {
      if(extra !== "border") {
        S.each(which, function(w) {
          if(!extra) {
            val -= parseFloat(Dom.css(elem, "padding" + w)) || 0
          }
          if(extra === "margin") {
            val += parseFloat(Dom.css(elem, extra + w)) || 0
          }else {
            val -= parseFloat(Dom.css(elem, "border" + w + "Width")) || 0
          }
        })
      }
      return val
    }
    val = Dom._getComputedStyle(elem, name);
    if(val === null || Number(val) < 0) {
      val = elem.style[name] || 0
    }
    val = parseFloat(val) || 0;
    if(extra) {
      S.each(which, function(w) {
        val += parseFloat(Dom.css(elem, "padding" + w)) || 0;
        if(extra !== "padding") {
          val += parseFloat(Dom.css(elem, "border" + w + "Width")) || 0
        }
        if(extra === "margin") {
          val += parseFloat(Dom.css(elem, extra + w)) || 0
        }
      })
    }
    return val
  }
  var ROOT_REG = /^(?:body|html)$/i;
  function getPosition(el) {
    var offsetParent, offset, parentOffset = {top:0, left:0};
    if(Dom.css(el, "position") === "fixed") {
      offset = el.getBoundingClientRect()
    }else {
      offsetParent = getOffsetParent(el);
      offset = Dom.offset(el);
      parentOffset = Dom.offset(offsetParent);
      parentOffset.top += parseFloat(Dom.css(offsetParent, "borderTopWidth")) || 0;
      parentOffset.left += parseFloat(Dom.css(offsetParent, "borderLeftWidth")) || 0
    }
    offset.top -= parseFloat(Dom.css(el, "marginTop")) || 0;
    offset.left -= parseFloat(Dom.css(el, "marginLeft")) || 0;
    return{top:offset.top - parentOffset.top, left:offset.left - parentOffset.left}
  }
  function getOffsetParent(el) {
    var offsetParent = el.offsetParent || (el.ownerDocument || doc).body;
    while(offsetParent && !ROOT_REG.test(offsetParent.nodeName) && Dom.css(offsetParent, "position") === "static") {
      offsetParent = offsetParent.offsetParent
    }
    return offsetParent
  }
  return Dom
});
KISSY.add("dom/base/selector", ["./api"], function(S, require) {
  var Dom = require("./api");
  var doc = S.Env.host.document, docElem = doc.documentElement, matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector, supportGetElementsByClassName = "getElementsByClassName" in doc, isArray = S.isArray, makeArray = S.makeArray, isDomNodeList = Dom.isDomNodeList, SPACE = " ", push = Array.prototype.push, rClassSelector = /^\.([\w-]+)$/, rIdSelector = /^#([\w-]+)$/, rTagSelector = /^([\w-])+$/, rTagIdSelector = 
  /^([\w-]+)#([\w-]+)$/, rSimpleSelector = /^(?:#([\w-]+))?\s*([\w-]+|\*)?\.?([\w-]+)?$/, trim = S.trim;
  function queryEach(f) {
    var self = this, l = self.length, i;
    for(i = 0;i < l;i++) {
      if(f(self[i], i) === false) {
        break
      }
    }
  }
  function checkSelectorAndReturn(selector) {
    var name = selector.substr(1);
    if(!name) {
      throw new Error("An invalid or illegal string was specified for selector.");
    }
    return name
  }
  function makeMatch(selector) {
    var s = selector.charAt(0);
    if(s === "#") {
      return makeIdMatch(checkSelectorAndReturn(selector))
    }else {
      if(s === ".") {
        return makeClassMatch(checkSelectorAndReturn(selector))
      }else {
        return makeTagMatch(selector)
      }
    }
  }
  function makeIdMatch(id) {
    return function(elem) {
      var match = Dom._getElementById(id, doc);
      return match && Dom._contains(elem, match) ? [match] : []
    }
  }
  function makeClassMatch(className) {
    return function(elem) {
      return elem.getElementsByClassName(className)
    }
  }
  function makeTagMatch(tagName) {
    return function(elem) {
      return elem.getElementsByTagName(tagName)
    }
  }
  function isSimpleSelector(selector) {
    var complexReg = /,|\+|=|~|\[|\]|:|>|\||\$|\^|\*|\(|\)|[\w-]+\.[\w-]+|[\w-]+#[\w-]+/;
    return!selector.match(complexReg)
  }
  function query(selector, context) {
    var ret, i, el, simpleContext, isSelectorString = typeof selector === "string", contexts = context !== undefined ? query(context) : (simpleContext = 1) && [doc], contextsLen = contexts.length;
    if(!selector) {
      ret = []
    }else {
      if(isSelectorString) {
        selector = trim(selector);
        if(simpleContext) {
          if(selector === "body") {
            ret = [doc.body]
          }else {
            if(rClassSelector.test(selector) && supportGetElementsByClassName) {
              ret = makeArray(doc.getElementsByClassName(RegExp.$1))
            }else {
              if(rTagIdSelector.test(selector)) {
                el = Dom._getElementById(RegExp.$2, doc);
                ret = el && el.nodeName.toLowerCase() === RegExp.$1 ? [el] : []
              }else {
                if(rIdSelector.test(selector)) {
                  el = Dom._getElementById(selector.substr(1), doc);
                  ret = el ? [el] : []
                }else {
                  if(rTagSelector.test(selector)) {
                    ret = makeArray(doc.getElementsByTagName(selector))
                  }else {
                    if(isSimpleSelector(selector) && supportGetElementsByClassName) {
                      var parts = selector.split(/\s+/), partsLen, parents = contexts, parentIndex, parentsLen;
                      for(i = 0, partsLen = parts.length;i < partsLen;i++) {
                        parts[i] = makeMatch(parts[i])
                      }
                      for(i = 0, partsLen = parts.length;i < partsLen;i++) {
                        var part = parts[i], newParents = [], matches;
                        for(parentIndex = 0, parentsLen = parents.length;parentIndex < parentsLen;parentIndex++) {
                          matches = part(parents[parentIndex]);
                          newParents.push.apply(newParents, makeArray(matches))
                        }
                        parents = newParents;
                        if(!parents.length) {
                          break
                        }
                      }
                      ret = parents && parents.length > 1 ? Dom.unique(parents) : parents
                    }
                  }
                }
              }
            }
          }
        }
        if(!ret) {
          ret = [];
          for(i = 0;i < contextsLen;i++) {
            push.apply(ret, Dom._selectInternal(selector, contexts[i]))
          }
          if(ret.length > 1 && contextsLen > 1) {
            Dom.unique(ret)
          }
        }
      }else {
        if(selector.nodeType || S.isWindow(selector)) {
          ret = [selector]
        }else {
          if(selector.getDOMNodes) {
            ret = selector.getDOMNodes()
          }else {
            if(isArray(selector)) {
              ret = selector
            }else {
              if(isDomNodeList(selector)) {
                ret = makeArray(selector)
              }else {
                ret = [selector]
              }
            }
          }
        }
        if(!simpleContext) {
          var tmp = ret, ci, len = tmp.length;
          ret = [];
          for(i = 0;i < len;i++) {
            for(ci = 0;ci < contextsLen;ci++) {
              if(Dom._contains(contexts[ci], tmp[i])) {
                ret.push(tmp[i]);
                break
              }
            }
          }
        }
      }
    }
    ret.each = queryEach;
    return ret
  }
  function hasSingleClass(el, cls) {
    var className = el && getAttr(el, "class");
    return className && (className = className.replace(/[\r\t\n]/g, SPACE)) && (SPACE + className + SPACE).indexOf(SPACE + cls + SPACE) > -1
  }
  function getAttr(el, name) {
    var ret = el && el.getAttributeNode(name);
    if(ret && ret.specified) {
      return ret.nodeValue
    }
    return undefined
  }
  function isTag(el, value) {
    return value === "*" || el.nodeName.toLowerCase() === value.toLowerCase()
  }
  S.mix(Dom, {_compareNodeOrder:function(a, b) {
    if(!a.compareDocumentPosition || !b.compareDocumentPosition) {
      return a.compareDocumentPosition ? -1 : 1
    }
    var bit = a.compareDocumentPosition(b) & 4;
    return bit ? -1 : 1
  }, _getElementsByTagName:function(name, context) {
    return makeArray(context.querySelectorAll(name))
  }, _getElementById:function(id, doc) {
    return doc.getElementById(id)
  }, _getSimpleAttr:getAttr, _isTag:isTag, _hasSingleClass:hasSingleClass, _matchesInternal:function(str, seeds) {
    var ret = [], i = 0, n, len = seeds.length;
    for(;i < len;i++) {
      n = seeds[i];
      if(matches.call(n, str)) {
        ret.push(n)
      }
    }
    return ret
  }, _selectInternal:function(str, context) {
    return makeArray(context.querySelectorAll(str))
  }, query:query, get:function(selector, context) {
    return query(selector, context)[0] || null
  }, unique:function() {
    var hasDuplicate, baseHasDuplicate = true;
    [0, 0].sort(function() {
      baseHasDuplicate = false;
      return 0
    });
    function sortOrder(a, b) {
      if(a === b) {
        hasDuplicate = true;
        return 0
      }
      return Dom._compareNodeOrder(a, b)
    }
    return function(elements) {
      hasDuplicate = baseHasDuplicate;
      elements.sort(sortOrder);
      if(hasDuplicate) {
        var i = 1, len = elements.length;
        while(i < len) {
          if(elements[i] === elements[i - 1]) {
            elements.splice(i, 1);
            --len
          }else {
            i++
          }
        }
      }
      return elements
    }
  }(), filter:function(selector, filter, context) {
    var elems = query(selector, context), id, tag, match, cls, ret = [];
    if(typeof filter === "string" && (filter = trim(filter)) && (match = rSimpleSelector.exec(filter))) {
      id = match[1];
      tag = match[2];
      cls = match[3];
      if(!id) {
        filter = function(elem) {
          var tagRe = true, clsRe = true;
          if(tag) {
            tagRe = isTag(elem, tag)
          }
          if(cls) {
            clsRe = hasSingleClass(elem, cls)
          }
          return clsRe && tagRe
        }
      }else {
        if(id && !tag && !cls) {
          filter = function(elem) {
            return getAttr(elem, "id") === id
          }
        }
      }
    }
    if(typeof filter === "function") {
      ret = S.filter(elems, filter)
    }else {
      ret = Dom._matchesInternal(filter, elems)
    }
    return ret
  }, test:function(selector, filter, context) {
    var elements = query(selector, context);
    return elements.length && Dom.filter(elements, filter, context).length === elements.length
  }});
  return Dom
});
KISSY.add("dom/base/traversal", ["./api"], function(S, require) {
  var Dom = require("./api");
  var NodeType = Dom.NodeType, CONTAIN_MASK = 16;
  S.mix(Dom, {_contains:function(a, b) {
    return!!(a.compareDocumentPosition(b) & CONTAIN_MASK)
  }, closest:function(selector, filter, context, allowTextNode) {
    return nth(selector, filter, "parentNode", function(elem) {
      return elem.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE
    }, context, true, allowTextNode)
  }, parent:function(selector, filter, context) {
    return nth(selector, filter, "parentNode", function(elem) {
      return elem.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE
    }, context, undefined)
  }, first:function(selector, filter, allowTextNode) {
    var elem = Dom.get(selector);
    return nth(elem && elem.firstChild, filter, "nextSibling", undefined, undefined, true, allowTextNode)
  }, last:function(selector, filter, allowTextNode) {
    var elem = Dom.get(selector);
    return nth(elem && elem.lastChild, filter, "previousSibling", undefined, undefined, true, allowTextNode)
  }, next:function(selector, filter, allowTextNode) {
    return nth(selector, filter, "nextSibling", undefined, undefined, undefined, allowTextNode)
  }, prev:function(selector, filter, allowTextNode) {
    return nth(selector, filter, "previousSibling", undefined, undefined, undefined, allowTextNode)
  }, siblings:function(selector, filter, allowTextNode) {
    return getSiblings(selector, filter, true, allowTextNode)
  }, children:function(selector, filter) {
    return getSiblings(selector, filter, undefined)
  }, contents:function(selector, filter) {
    return getSiblings(selector, filter, undefined, 1)
  }, contains:function(container, contained) {
    container = Dom.get(container);
    contained = Dom.get(contained);
    if(container && contained) {
      return Dom._contains(container, contained)
    }
    return false
  }, index:function(selector, s2) {
    var els = Dom.query(selector), c, n = 0, p, els2, el = els[0];
    if(!s2) {
      p = el && el.parentNode;
      if(!p) {
        return-1
      }
      c = el;
      while(c = c.previousSibling) {
        if(c.nodeType === NodeType.ELEMENT_NODE) {
          n++
        }
      }
      return n
    }
    els2 = Dom.query(s2);
    if(typeof s2 === "string") {
      return S.indexOf(el, els2)
    }
    return S.indexOf(els2[0], els)
  }, equals:function(n1, n2) {
    n1 = Dom.query(n1);
    n2 = Dom.query(n2);
    if(n1.length !== n2.length) {
      return false
    }
    for(var i = n1.length;i >= 0;i--) {
      if(n1[i] !== n2[i]) {
        return false
      }
    }
    return true
  }});
  function nth(elem, filter, direction, extraFilter, context, includeSef, allowTextNode) {
    if(!(elem = Dom.get(elem))) {
      return null
    }
    if(filter === 0) {
      return elem
    }
    if(!includeSef) {
      elem = elem[direction]
    }
    if(!elem) {
      return null
    }
    context = context && Dom.get(context) || null;
    if(filter === undefined) {
      filter = 1
    }
    var ret = [], isArray = S.isArray(filter), fi, filterLength;
    if(typeof filter === "number") {
      fi = 0;
      filterLength = filter;
      filter = function() {
        return++fi === filterLength
      }
    }
    while(elem && elem !== context) {
      if((elem.nodeType === NodeType.ELEMENT_NODE || elem.nodeType === NodeType.TEXT_NODE && allowTextNode) && testFilter(elem, filter) && (!extraFilter || extraFilter(elem))) {
        ret.push(elem);
        if(!isArray) {
          break
        }
      }
      elem = elem[direction]
    }
    return isArray ? ret : ret[0] || null
  }
  function testFilter(elem, filter) {
    if(!filter) {
      return true
    }
    if(S.isArray(filter)) {
      var i, l = filter.length;
      if(!l) {
        return true
      }
      for(i = 0;i < l;i++) {
        if(Dom.test(elem, filter[i])) {
          return true
        }
      }
    }else {
      if(Dom.test(elem, filter)) {
        return true
      }
    }
    return false
  }
  function getSiblings(selector, filter, parent, allowText) {
    var ret = [], tmp, i, el, elem = Dom.get(selector), parentNode = elem;
    if(elem && parent) {
      parentNode = elem.parentNode
    }
    if(parentNode) {
      tmp = S.makeArray(parentNode.childNodes);
      for(i = 0;i < tmp.length;i++) {
        el = tmp[i];
        if(!allowText && el.nodeType !== NodeType.ELEMENT_NODE) {
          continue
        }
        if(el === elem) {
          continue
        }
        ret.push(el)
      }
      if(filter) {
        ret = Dom.filter(ret, filter)
      }
    }
    return ret
  }
  return Dom
});
KISSY.add("dom/base", ["./base/api", "./base/attr", "./base/class", "./base/create", "./base/data", "./base/insertion", "./base/offset", "./base/style", "./base/selector", "./base/traversal"], function(S, require) {
  var Dom = require("./base/api");
  require("./base/attr");
  require("./base/class");
  require("./base/create");
  require("./base/data");
  require("./base/insertion");
  require("./base/offset");
  require("./base/style");
  require("./base/selector");
  require("./base/traversal");
  S.mix(S, {DOM:Dom, get:Dom.get, query:Dom.query});
  return Dom
});

/*
Copyright 2013, KISSY v1.42
MIT Licensed
build time: Dec 4 22:16
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 event
*/

KISSY.add("event", ["event/dom", "event/custom"], function(S, require) {
  var DomEvent = require("event/dom");
  var CustomEvent = require("event/custom");
  var Event = S.Event = S.merge(DomEvent, {DomEvent:DomEvent, CustomEvent:CustomEvent});
  Event.global = CustomEvent.global;
  S.EventTarget = Event.Target = CustomEvent.Target;
  return Event
});

/*
Copyright 2013, KISSY v1.42
MIT Licensed
build time: Dec 4 22:15
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 event/dom/base/utils
 event/dom/base/special
 event/dom/base/observer
 event/dom/base/object
 event/dom/base/observable
 event/dom/base/dom-event
 event/dom/base/key-codes
 event/dom/base/gesture
 event/dom/base/special-events
 event/dom/base/mouseenter
 event/dom/base/valuechange
 event/dom/base
*/

KISSY.add("event/dom/base/utils", ["dom"], function(S, require) {
  var Dom = require("dom");
  var EVENT_GUID = "ksEventTargetId_" + S.now(), doc = S.Env.host.document, simpleAdd = doc && doc.addEventListener ? function(el, type, fn, capture) {
    if(el.addEventListener) {
      el.addEventListener(type, fn, !!capture)
    }
  } : function(el, type, fn) {
    if(el.attachEvent) {
      el.attachEvent("on" + type, fn)
    }
  }, simpleRemove = doc && doc.removeEventListener ? function(el, type, fn, capture) {
    if(el.removeEventListener) {
      el.removeEventListener(type, fn, !!capture)
    }
  } : function(el, type, fn) {
    if(el.detachEvent) {
      el.detachEvent("on" + type, fn)
    }
  };
  return{simpleAdd:simpleAdd, simpleRemove:simpleRemove, data:function(elem, v) {
    return Dom.data(elem, EVENT_GUID, v)
  }, removeData:function(elem) {
    return Dom.removeData(elem, EVENT_GUID)
  }}
});
KISSY.add("event/dom/base/special", [], function() {
  return{}
});
KISSY.add("event/dom/base/observer", ["event/base", "./special"], function(S, require) {
  var BaseEvent = require("event/base");
  var Special = require("./special");
  function DomEventObserver(cfg) {
    DomEventObserver.superclass.constructor.call(this, cfg)
  }
  S.extend(DomEventObserver, BaseEvent.Observer, {keys:["fn", "filter", "data", "context", "originalType", "groups", "last"], notifyInternal:function(event, ce) {
    var self = this, s, t, ret, type = event.type, originalType;
    if(originalType = self.originalType) {
      event.type = originalType
    }else {
      originalType = type
    }
    if((s = Special[originalType]) && s.handle) {
      t = s.handle(event, self, ce);
      if(t && t.length > 0) {
        ret = t[0]
      }
    }else {
      ret = self.simpleNotify(event, ce)
    }
    if(ret === false) {
      event.halt()
    }
    event.type = type;
    return ret
  }});
  return DomEventObserver
});
KISSY.add("event/dom/base/object", ["event/base"], function(S, require) {
  var BaseEvent = require("event/base");
  var DOCUMENT = S.Env.host.document, TRUE = true, FALSE = false, commonProps = ["altKey", "bubbles", "cancelable", "ctrlKey", "currentTarget", "eventPhase", "metaKey", "shiftKey", "target", "timeStamp", "view", "type"], eventNormalizers = [{reg:/^key/, props:["char", "charCode", "key", "keyCode", "which"], fix:function(event, originalEvent) {
    if(event.which == null) {
      event.which = originalEvent.charCode != null ? originalEvent.charCode : originalEvent.keyCode
    }
    if(event.metaKey === undefined) {
      event.metaKey = event.ctrlKey
    }
  }}, {reg:/^touch/, props:["touches", "changedTouches", "targetTouches"]}, {reg:/^gesturechange$/i, props:["rotation", "scale"]}, {reg:/^(mousewheel|DOMMouseScroll)$/, props:[], fix:function(event, originalEvent) {
    var deltaX, deltaY, delta, wheelDelta = originalEvent.wheelDelta, axis = originalEvent.axis, wheelDeltaY = originalEvent.wheelDeltaY, wheelDeltaX = originalEvent.wheelDeltaX, detail = originalEvent.detail;
    if(wheelDelta) {
      delta = wheelDelta / 120
    }
    if(detail) {
      delta = -(detail % 3 === 0 ? detail / 3 : detail)
    }
    if(axis !== undefined) {
      if(axis === event.HORIZONTAL_AXIS) {
        deltaY = 0;
        deltaX = -1 * delta
      }else {
        if(axis === event.VERTICAL_AXIS) {
          deltaX = 0;
          deltaY = delta
        }
      }
    }
    if(wheelDeltaY !== undefined) {
      deltaY = wheelDeltaY / 120
    }
    if(wheelDeltaX !== undefined) {
      deltaX = -1 * wheelDeltaX / 120
    }
    if(!deltaX && !deltaY) {
      deltaY = delta
    }
    if(deltaX !== undefined) {
      event.deltaX = deltaX
    }
    if(deltaY !== undefined) {
      event.deltaY = deltaY
    }
    if(delta !== undefined) {
      event.delta = delta
    }
  }}, {reg:/^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i, props:["buttons", "clientX", "clientY", "button", "offsetX", "relatedTarget", "which", "fromElement", "toElement", "offsetY", "pageX", "pageY", "screenX", "screenY"], fix:function(event, originalEvent) {
    var eventDoc, doc, body, target = event.target, button = originalEvent.button;
    if(event.pageX == null && originalEvent.clientX != null) {
      eventDoc = target.ownerDocument || DOCUMENT;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      event.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
    }
    if(!event.which && button !== undefined) {
      event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0
    }
    if(!event.relatedTarget && event.fromElement) {
      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement
    }
    return event
  }}];
  function retTrue() {
    return TRUE
  }
  function retFalse() {
    return FALSE
  }
  function DomEventObject(originalEvent) {
    var self = this, type = originalEvent.type;
    DomEventObject.superclass.constructor.call(self);
    self.originalEvent = originalEvent;
    var isDefaultPrevented = retFalse;
    if("defaultPrevented" in originalEvent) {
      isDefaultPrevented = originalEvent.defaultPrevented ? retTrue : retFalse
    }else {
      if("getPreventDefault" in originalEvent) {
        isDefaultPrevented = originalEvent.getPreventDefault() ? retTrue : retFalse
      }else {
        if("returnValue" in originalEvent) {
          isDefaultPrevented = originalEvent.returnValue === FALSE ? retTrue : retFalse
        }
      }
    }
    self.isDefaultPrevented = isDefaultPrevented;
    var fixFns = [], fixFn, l, prop, props = commonProps.concat();
    S.each(eventNormalizers, function(normalizer) {
      if(type.match(normalizer.reg)) {
        props = props.concat(normalizer.props);
        if(normalizer.fix) {
          fixFns.push(normalizer.fix)
        }
      }
      return undefined
    });
    l = props.length;
    while(l) {
      prop = props[--l];
      self[prop] = originalEvent[prop]
    }
    if(!self.target) {
      self.target = originalEvent.srcElement || DOCUMENT
    }
    if(self.target.nodeType === 3) {
      self.target = self.target.parentNode
    }
    l = fixFns.length;
    while(l) {
      fixFn = fixFns[--l];
      fixFn(self, originalEvent)
    }
  }
  S.extend(DomEventObject, BaseEvent.Object, {constructor:DomEventObject, preventDefault:function() {
    var self = this, e = self.originalEvent;
    if(e.preventDefault) {
      e.preventDefault()
    }else {
      e.returnValue = FALSE
    }
    DomEventObject.superclass.preventDefault.call(self)
  }, stopPropagation:function() {
    var self = this, e = self.originalEvent;
    if(e.stopPropagation) {
      e.stopPropagation()
    }else {
      e.cancelBubble = TRUE
    }
    DomEventObject.superclass.stopPropagation.call(self)
  }});
  return DomEventObject
});
KISSY.add("event/dom/base/observable", ["event/base", "dom", "./special", "./utils", "./observer", "./object"], function(S, require) {
  var BaseEvent = require("event/base");
  var Dom = require("dom");
  var Special = require("./special");
  var DomEventUtils = require("./utils");
  var DomEventObserver = require("./observer");
  var DomEventObject = require("./object");
  var BaseUtils = BaseEvent.Utils;
  var logger = S.getLogger("s/event");
  function DomEventObservable(cfg) {
    var self = this;
    S.mix(self, cfg);
    self.reset()
  }
  S.extend(DomEventObservable, BaseEvent.Observable, {setup:function() {
    var self = this, type = self.type, s = Special[type] || {}, currentTarget = self.currentTarget, eventDesc = DomEventUtils.data(currentTarget), handle = eventDesc.handle;
    if(!s.setup || s.setup.call(currentTarget, type) === false) {
      DomEventUtils.simpleAdd(currentTarget, type, handle)
    }
  }, constructor:DomEventObservable, reset:function() {
    var self = this;
    DomEventObservable.superclass.reset.call(self);
    self.delegateCount = 0;
    self.lastCount = 0
  }, notify:function(event) {
    var target = event.target, eventType = event.type, self = this, currentTarget = self.currentTarget, observers = self.observers, currentTarget0, allObservers = [], ret, gRet, observerObj, i, j, delegateCount = self.delegateCount || 0, len, currentTargetObservers, currentTargetObserver, observer;
    if(delegateCount && target.nodeType) {
      while(target !== currentTarget) {
        if(target.disabled !== true || eventType !== "click") {
          var cachedMatch = {}, matched, key, filter;
          currentTargetObservers = [];
          for(i = 0;i < delegateCount;i++) {
            observer = observers[i];
            filter = observer.filter;
            key = filter + "";
            matched = cachedMatch[key];
            if(matched === undefined) {
              matched = cachedMatch[key] = Dom.test(target, filter)
            }
            if(matched) {
              currentTargetObservers.push(observer)
            }
          }
          if(currentTargetObservers.length) {
            allObservers.push({currentTarget:target, currentTargetObservers:currentTargetObservers})
          }
        }
        target = target.parentNode || currentTarget
      }
    }
    if(delegateCount < observers.length) {
      allObservers.push({currentTarget:currentTarget, currentTargetObservers:observers.slice(delegateCount)})
    }
    for(i = 0, len = allObservers.length;!event.isPropagationStopped() && i < len;++i) {
      observerObj = allObservers[i];
      currentTargetObservers = observerObj.currentTargetObservers;
      currentTarget0 = observerObj.currentTarget;
      event.currentTarget = currentTarget0;
      for(j = 0;!event.isImmediatePropagationStopped() && j < currentTargetObservers.length;j++) {
        currentTargetObserver = currentTargetObservers[j];
        ret = currentTargetObserver.notify(event, self);
        if(gRet !== false && ret !== undefined) {
          gRet = ret
        }
      }
    }
    return gRet
  }, fire:function(event, onlyHandlers) {
    event = event || {};
    var self = this, eventType = String(self.type), domEventObservable, eventData, specialEvent = Special[eventType] || {}, bubbles = specialEvent.bubbles !== false, currentTarget = self.currentTarget;
    if(specialEvent.fire && specialEvent.fire.call(currentTarget, onlyHandlers) === false) {
      return
    }
    if(!(event instanceof DomEventObject)) {
      eventData = event;
      event = new DomEventObject({currentTarget:currentTarget, type:eventType, target:currentTarget});
      S.mix(event, eventData)
    }
    if(specialEvent.preFire && specialEvent.preFire.call(currentTarget, event, onlyHandlers) === false) {
      return
    }
    var cur = currentTarget, win = Dom.getWindow(cur), curDocument = win.document, eventPath = [], gret, ret, ontype = "on" + eventType, eventPathIndex = 0;
    do {
      eventPath.push(cur);
      cur = cur.parentNode || cur.ownerDocument || cur === curDocument && win
    }while(!onlyHandlers && cur && bubbles);
    cur = eventPath[eventPathIndex];
    do {
      event.currentTarget = cur;
      domEventObservable = DomEventObservable.getDomEventObservable(cur, eventType);
      if(domEventObservable) {
        ret = domEventObservable.notify(event);
        if(ret !== undefined && gret !== false) {
          gret = ret
        }
      }
      if(cur[ontype] && cur[ontype].call(cur) === false) {
        event.preventDefault()
      }
      cur = eventPath[++eventPathIndex]
    }while(!onlyHandlers && cur && !event.isPropagationStopped());
    if(!onlyHandlers && !event.isDefaultPrevented()) {
      try {
        if(currentTarget[eventType] && !S.isWindow(currentTarget)) {
          DomEventObservable.triggeredEvent = eventType;
          currentTarget[eventType]()
        }
      }catch(eError) {
        logger.debug("trigger action error: " + eError)
      }
      DomEventObservable.triggeredEvent = ""
    }
    return gret
  }, on:function(cfg) {
    var self = this, observers = self.observers, s = Special[self.type] || {}, observer = cfg instanceof DomEventObserver ? cfg : new DomEventObserver(cfg);
    if(S.Config.debug) {
      if(!observer.fn) {
        S.error("lack event handler for " + self.type)
      }
    }
    if(self.findObserver(observer) === -1) {
      if(observer.filter) {
        observers.splice(self.delegateCount, 0, observer);
        self.delegateCount++
      }else {
        if(observer.last) {
          observers.push(observer);
          self.lastCount++
        }else {
          observers.splice(observers.length - self.lastCount, 0, observer)
        }
      }
      if(s.add) {
        s.add.call(self.currentTarget, observer)
      }
    }
  }, detach:function(cfg) {
    var groupsRe, self = this, s = Special[self.type] || {}, hasFilter = "filter" in cfg, filter = cfg.filter, context = cfg.context, fn = cfg.fn, currentTarget = self.currentTarget, observers = self.observers, groups = cfg.groups;
    if(!observers.length) {
      return
    }
    if(groups) {
      groupsRe = BaseUtils.getGroupsRe(groups)
    }
    var i, j, t, observer, observerContext, len = observers.length;
    if(fn || hasFilter || groupsRe) {
      context = context || currentTarget;
      for(i = 0, j = 0, t = [];i < len;++i) {
        observer = observers[i];
        observerContext = observer.context || currentTarget;
        if(context !== observerContext || fn && fn !== observer.fn || hasFilter && (filter && filter !== observer.filter || !filter && !observer.filter) || groupsRe && !observer.groups.match(groupsRe)) {
          t[j++] = observer
        }else {
          if(observer.filter && self.delegateCount) {
            self.delegateCount--
          }
          if(observer.last && self.lastCount) {
            self.lastCount--
          }
          if(s.remove) {
            s.remove.call(currentTarget, observer)
          }
        }
      }
      self.observers = t
    }else {
      self.reset()
    }
    self.checkMemory()
  }, checkMemory:function() {
    var self = this, type = self.type, domEventObservables, handle, s = Special[type] || {}, currentTarget = self.currentTarget, eventDesc = DomEventUtils.data(currentTarget);
    if(eventDesc) {
      domEventObservables = eventDesc.observables;
      if(!self.hasObserver()) {
        handle = eventDesc.handle;
        if(!s.tearDown || s.tearDown.call(currentTarget, type) === false) {
          DomEventUtils.simpleRemove(currentTarget, type, handle)
        }
        delete domEventObservables[type]
      }
      if(S.isEmptyObject(domEventObservables)) {
        eventDesc.handle = null;
        DomEventUtils.removeData(currentTarget)
      }
    }
  }});
  DomEventObservable.triggeredEvent = "";
  DomEventObservable.getDomEventObservable = function(node, type) {
    var domEventObservablesHolder = DomEventUtils.data(node), domEventObservables;
    if(domEventObservablesHolder) {
      domEventObservables = domEventObservablesHolder.observables
    }
    if(domEventObservables) {
      return domEventObservables[type]
    }
    return null
  };
  DomEventObservable.getDomEventObservablesHolder = function(node, create) {
    var domEventObservables = DomEventUtils.data(node);
    if(!domEventObservables && create) {
      DomEventUtils.data(node, domEventObservables = {})
    }
    return domEventObservables
  };
  return DomEventObservable
});
KISSY.add("event/dom/base/dom-event", ["event/base", "./utils", "dom", "./special", "./observable", "./object"], function(S, require) {
  var BaseEvent = require("event/base");
  var DomEventUtils = require("./utils");
  var Dom = require("dom");
  var Special = require("./special");
  var DomEventObservable = require("./observable");
  var DomEventObject = require("./object");
  var BaseUtils = BaseEvent.Utils;
  function fixType(cfg, type) {
    var s = Special[type] || {}, typeFix;
    if(!cfg.originalType && (typeFix = s.typeFix)) {
      cfg.originalType = type;
      type = typeFix
    }
    return type
  }
  function addInternal(currentTarget, type, cfg) {
    var domEventObservablesHolder, domEventObservable, domEventObservables, handle;
    cfg = S.merge(cfg);
    type = fixType(cfg, type);
    domEventObservablesHolder = DomEventObservable.getDomEventObservablesHolder(currentTarget, 1);
    if(!(handle = domEventObservablesHolder.handle)) {
      handle = domEventObservablesHolder.handle = function(event) {
        var type = event.type, domEventObservable, currentTarget = handle.currentTarget;
        if(DomEventObservable.triggeredEvent === type || typeof KISSY === "undefined") {
          return undefined
        }
        domEventObservable = DomEventObservable.getDomEventObservable(currentTarget, type);
        if(domEventObservable) {
          event.currentTarget = currentTarget;
          event = new DomEventObject(event);
          return domEventObservable.notify(event)
        }
        return undefined
      };
      handle.currentTarget = currentTarget
    }
    if(!(domEventObservables = domEventObservablesHolder.observables)) {
      domEventObservables = domEventObservablesHolder.observables = {}
    }
    domEventObservable = domEventObservables[type];
    if(!domEventObservable) {
      domEventObservable = domEventObservables[type] = new DomEventObservable({type:type, currentTarget:currentTarget});
      domEventObservable.setup()
    }
    domEventObservable.on(cfg);
    currentTarget = null
  }
  function removeInternal(currentTarget, type, cfg) {
    cfg = S.merge(cfg);
    var customEvent;
    type = fixType(cfg, type);
    var domEventObservablesHolder = DomEventObservable.getDomEventObservablesHolder(currentTarget), domEventObservables = (domEventObservablesHolder || {}).observables;
    if(!domEventObservablesHolder || !domEventObservables) {
      return
    }
    if(!type) {
      for(type in domEventObservables) {
        domEventObservables[type].detach(cfg)
      }
      return
    }
    customEvent = domEventObservables[type];
    if(customEvent) {
      customEvent.detach(cfg)
    }
  }
  var DomEvent = {on:function(targets, type, fn, context) {
    targets = Dom.query(targets);
    BaseUtils.batchForType(function(targets, type, fn, context) {
      var cfg = BaseUtils.normalizeParam(type, fn, context), i, t;
      type = cfg.type;
      for(i = targets.length - 1;i >= 0;i--) {
        t = targets[i];
        addInternal(t, type, cfg)
      }
    }, 1, targets, type, fn, context);
    return targets
  }, detach:function(targets, type, fn, context) {
    targets = Dom.query(targets);
    BaseUtils.batchForType(function(targets, singleType, fn, context) {
      var cfg = BaseUtils.normalizeParam(singleType, fn, context), i, j, elChildren, t;
      singleType = cfg.type;
      for(i = targets.length - 1;i >= 0;i--) {
        t = targets[i];
        removeInternal(t, singleType, cfg);
        if(cfg.deep && t.getElementsByTagName) {
          elChildren = t.getElementsByTagName("*");
          for(j = elChildren.length - 1;j >= 0;j--) {
            removeInternal(elChildren[j], singleType, cfg)
          }
        }
      }
    }, 1, targets, type, fn, context);
    return targets
  }, delegate:function(targets, eventType, filter, fn, context) {
    return DomEvent.on(targets, eventType, {fn:fn, context:context, filter:filter})
  }, undelegate:function(targets, eventType, filter, fn, context) {
    return DomEvent.detach(targets, eventType, {fn:fn, context:context, filter:filter})
  }, fire:function(targets, eventType, eventData, onlyHandlers) {
    var ret;
    eventData = eventData || {};
    eventData.synthetic = 1;
    BaseUtils.splitAndRun(eventType, function(eventType) {
      var r, i, target, domEventObservable;
      BaseUtils.fillGroupsForEvent(eventType, eventData);
      eventType = eventData.type;
      var s = Special[eventType];
      var originalType = eventType;
      if(s && s.typeFix) {
        originalType = s.typeFix
      }
      targets = Dom.query(targets);
      for(i = targets.length - 1;i >= 0;i--) {
        target = targets[i];
        domEventObservable = DomEventObservable.getDomEventObservable(target, originalType);
        if(!onlyHandlers && !domEventObservable) {
          domEventObservable = new DomEventObservable({type:originalType, currentTarget:target})
        }
        if(domEventObservable) {
          r = domEventObservable.fire(eventData, onlyHandlers);
          if(ret !== false && r !== undefined) {
            ret = r
          }
        }
      }
    });
    return ret
  }, fireHandler:function(targets, eventType, eventData) {
    return DomEvent.fire(targets, eventType, eventData, 1)
  }, clone:function(src, dest) {
    var domEventObservablesHolder, domEventObservables;
    if(!(domEventObservablesHolder = DomEventObservable.getDomEventObservablesHolder(src))) {
      return
    }
    var srcData = DomEventUtils.data(src);
    if(srcData && srcData === DomEventUtils.data(dest)) {
      DomEventUtils.removeData(dest)
    }
    domEventObservables = domEventObservablesHolder.observables;
    S.each(domEventObservables, function(customEvent, type) {
      S.each(customEvent.observers, function(observer) {
        addInternal(dest, type, observer)
      })
    })
  }};
  return DomEvent
});
KISSY.add("event/dom/base/key-codes", [], function(S) {
  var UA = S.UA, KeyCode = {MAC_ENTER:3, BACKSPACE:8, TAB:9, NUM_CENTER:12, ENTER:13, SHIFT:16, CTRL:17, ALT:18, PAUSE:19, CAPS_LOCK:20, ESC:27, SPACE:32, PAGE_UP:33, PAGE_DOWN:34, END:35, HOME:36, LEFT:37, UP:38, RIGHT:39, DOWN:40, PRINT_SCREEN:44, INSERT:45, DELETE:46, ZERO:48, ONE:49, TWO:50, THREE:51, FOUR:52, FIVE:53, SIX:54, SEVEN:55, EIGHT:56, NINE:57, QUESTION_MARK:63, A:65, B:66, C:67, D:68, E:69, F:70, G:71, H:72, I:73, J:74, K:75, L:76, M:77, N:78, O:79, P:80, Q:81, R:82, S:83, T:84, U:85, 
  V:86, W:87, X:88, Y:89, Z:90, META:91, WIN_KEY_RIGHT:92, CONTEXT_MENU:93, NUM_ZERO:96, NUM_ONE:97, NUM_TWO:98, NUM_THREE:99, NUM_FOUR:100, NUM_FIVE:101, NUM_SIX:102, NUM_SEVEN:103, NUM_EIGHT:104, NUM_NINE:105, NUM_MULTIPLY:106, NUM_PLUS:107, NUM_MINUS:109, NUM_PERIOD:110, NUM_DIVISION:111, F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123, NUMLOCK:144, SEMICOLON:186, DASH:189, EQUALS:187, COMMA:188, PERIOD:190, SLASH:191, APOSTROPHE:192, SINGLE_QUOTE:222, 
  OPEN_SQUARE_BRACKET:219, BACKSLASH:220, CLOSE_SQUARE_BRACKET:221, WIN_KEY:224, MAC_FF_META:224, WIN_IME:229};
  KeyCode.isTextModifyingKeyEvent = function(e) {
    var keyCode = e.keyCode;
    if(e.altKey && !e.ctrlKey || e.metaKey || keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false
    }
    switch(keyCode) {
      case KeyCode.ALT:
      ;
      case KeyCode.CAPS_LOCK:
      ;
      case KeyCode.CONTEXT_MENU:
      ;
      case KeyCode.CTRL:
      ;
      case KeyCode.DOWN:
      ;
      case KeyCode.END:
      ;
      case KeyCode.ESC:
      ;
      case KeyCode.HOME:
      ;
      case KeyCode.INSERT:
      ;
      case KeyCode.LEFT:
      ;
      case KeyCode.MAC_FF_META:
      ;
      case KeyCode.META:
      ;
      case KeyCode.NUMLOCK:
      ;
      case KeyCode.NUM_CENTER:
      ;
      case KeyCode.PAGE_DOWN:
      ;
      case KeyCode.PAGE_UP:
      ;
      case KeyCode.PAUSE:
      ;
      case KeyCode.PRINT_SCREEN:
      ;
      case KeyCode.RIGHT:
      ;
      case KeyCode.SHIFT:
      ;
      case KeyCode.UP:
      ;
      case KeyCode.WIN_KEY:
      ;
      case KeyCode.WIN_KEY_RIGHT:
        return false;
      default:
        return true
    }
  };
  KeyCode.isCharacterKey = function(keyCode) {
    if(keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true
    }
    if(keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true
    }
    if(keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true
    }
    if(UA.webkit && keyCode === 0) {
      return true
    }
    switch(keyCode) {
      case KeyCode.SPACE:
      ;
      case KeyCode.QUESTION_MARK:
      ;
      case KeyCode.NUM_PLUS:
      ;
      case KeyCode.NUM_MINUS:
      ;
      case KeyCode.NUM_PERIOD:
      ;
      case KeyCode.NUM_DIVISION:
      ;
      case KeyCode.SEMICOLON:
      ;
      case KeyCode.DASH:
      ;
      case KeyCode.EQUALS:
      ;
      case KeyCode.COMMA:
      ;
      case KeyCode.PERIOD:
      ;
      case KeyCode.SLASH:
      ;
      case KeyCode.APOSTROPHE:
      ;
      case KeyCode.SINGLE_QUOTE:
      ;
      case KeyCode.OPEN_SQUARE_BRACKET:
      ;
      case KeyCode.BACKSLASH:
      ;
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;
      default:
        return false
    }
  };
  return KeyCode
});
KISSY.add("event/dom/base/gesture", [], function() {
  return{start:"mousedown", move:"mousemove", end:"mouseup", tap:"click", singleTap:"click", doubleTap:"dblclick"}
});
KISSY.add("event/dom/base/special-events", ["./dom-event", "./special"], function(S, require) {
  var DomEvent = require("./dom-event");
  var Special = require("./special");
  var UA = S.UA, MOUSE_WHEEL = UA.gecko ? "DOMMouseScroll" : "mousewheel";
  return S.mix(Special, {mousewheel:{typeFix:MOUSE_WHEEL}, load:{bubbles:false}, click:{fire:function(onlyHandlers) {
    var target = this;
    if(!onlyHandlers && String(target.type) === "checkbox" && target.click && target.nodeName.toLowerCase() === "input") {
      target.click();
      return false
    }
    return undefined
  }}, focus:{bubbles:false, preFire:function(event, onlyHandlers) {
    if(!onlyHandlers) {
      return DomEvent.fire(this, "focusin")
    }
  }, fire:function(onlyHandlers) {
    var target = this;
    if(!onlyHandlers && target.ownerDocument) {
      if(target !== target.ownerDocument.activeElement && target.focus) {
        target.focus();
        return false
      }
    }
    return undefined
  }}, blur:{bubbles:false, preFire:function(event, onlyHandlers) {
    if(!onlyHandlers) {
      return DomEvent.fire(this, "focusout")
    }
  }, fire:function(onlyHandlers) {
    var target = this;
    if(!onlyHandlers && target.ownerDocument) {
      if(target === target.ownerDocument.activeElement && target.blur) {
        target.blur();
        return false
      }
    }
    return undefined
  }}})
});
KISSY.add("event/dom/base/mouseenter", ["dom", "./special"], function(S, require) {
  var Dom = require("dom");
  var Special = require("./special");
  S.each([{name:"mouseenter", fix:"mouseover"}, {name:"mouseleave", fix:"mouseout"}], function(o) {
    Special[o.name] = {typeFix:o.fix, handle:function(event, observer, ce) {
      var currentTarget = event.currentTarget, relatedTarget = event.relatedTarget;
      if(!relatedTarget || relatedTarget !== currentTarget && !Dom.contains(currentTarget, relatedTarget)) {
        return[observer.simpleNotify(event, ce)]
      }
    }}
  })
});
KISSY.add("event/dom/base/valuechange", ["dom", "./dom-event", "./special"], function(S, require) {
  var Dom = require("dom");
  var DomEvent = require("./dom-event");
  var Special = require("./special");
  var VALUE_CHANGE = "valuechange", getNodeName = Dom.nodeName, KEY = "event/valuechange", HISTORY_KEY = KEY + "/history", POLL_KEY = KEY + "/poll", interval = 50;
  function clearPollTimer(target) {
    if(Dom.hasData(target, POLL_KEY)) {
      var poll = Dom.data(target, POLL_KEY);
      clearTimeout(poll);
      Dom.removeData(target, POLL_KEY)
    }
  }
  function stopPoll(target) {
    Dom.removeData(target, HISTORY_KEY);
    clearPollTimer(target)
  }
  function stopPollHandler(ev) {
    clearPollTimer(ev.target)
  }
  function checkChange(target) {
    var v = target.value, h = Dom.data(target, HISTORY_KEY);
    if(v !== h) {
      DomEvent.fireHandler(target, VALUE_CHANGE, {prevVal:h, newVal:v});
      Dom.data(target, HISTORY_KEY, v)
    }
  }
  function startPoll(target) {
    if(Dom.hasData(target, POLL_KEY)) {
      return
    }
    Dom.data(target, POLL_KEY, setTimeout(function check() {
      checkChange(target);
      Dom.data(target, POLL_KEY, setTimeout(check, interval))
    }, interval))
  }
  function startPollHandler(ev) {
    var target = ev.target;
    if(ev.type === "focus") {
      Dom.data(target, HISTORY_KEY, target.value)
    }
    startPoll(target)
  }
  function webkitSpeechChangeHandler(e) {
    checkChange(e.target)
  }
  function monitor(target) {
    unmonitored(target);
    DomEvent.on(target, "blur", stopPollHandler);
    DomEvent.on(target, "webkitspeechchange", webkitSpeechChangeHandler);
    DomEvent.on(target, "mousedown keyup keydown focus", startPollHandler)
  }
  function unmonitored(target) {
    stopPoll(target);
    DomEvent.detach(target, "blur", stopPollHandler);
    DomEvent.detach(target, "webkitspeechchange", webkitSpeechChangeHandler);
    DomEvent.detach(target, "mousedown keyup keydown focus", startPollHandler)
  }
  Special[VALUE_CHANGE] = {setup:function() {
    var target = this, nodeName = getNodeName(target);
    if(nodeName === "input" || nodeName === "textarea") {
      monitor(target)
    }
  }, tearDown:function() {
    var target = this;
    unmonitored(target)
  }};
  return DomEvent
});
KISSY.add("event/dom/base", ["./base/dom-event", "./base/object", "./base/key-codes", "./base/gesture", "./base/special-events", "./base/mouseenter", "./base/valuechange"], function(S, require) {
  var DomEvent = require("./base/dom-event");
  var DomEventObject = require("./base/object");
  var KeyCode = require("./base/key-codes");
  var Gesture = require("./base/gesture");
  var Special = require("./base/special-events");
  require("./base/mouseenter");
  require("./base/valuechange");
  return S.merge({add:DomEvent.on, remove:DomEvent.detach, KeyCode:KeyCode, Gesture:Gesture, Special:Special, Object:DomEventObject}, DomEvent)
});

/*
Copyright 2013, KISSY v1.42
MIT Licensed
build time: Dec 4 22:15
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 event/base/utils
 event/base/object
 event/base/observer
 event/base/observable
 event/base
*/

KISSY.add("event/base/utils", [], function(S) {
  var splitAndRun, getGroupsRe;
  function getTypedGroups(type) {
    if(type.indexOf(".") < 0) {
      return[type, ""]
    }
    var m = type.match(/([^.]+)?(\..+)?$/), t = m[1], ret = [t], gs = m[2];
    if(gs) {
      gs = gs.split(".").sort();
      ret.push(gs.join("."))
    }else {
      ret.push("")
    }
    return ret
  }
  return{splitAndRun:splitAndRun = function(type, fn) {
    if(S.isArray(type)) {
      S.each(type, fn);
      return
    }
    type = S.trim(type);
    if(type.indexOf(" ") === -1) {
      fn(type)
    }else {
      S.each(type.split(/\s+/), fn)
    }
  }, normalizeParam:function(type, fn, context) {
    var cfg = fn || {};
    if(typeof fn === "function") {
      cfg = {fn:fn, context:context}
    }else {
      cfg = S.merge(cfg)
    }
    var typedGroups = getTypedGroups(type);
    type = typedGroups[0];
    cfg.groups = typedGroups[1];
    cfg.type = type;
    return cfg
  }, batchForType:function(fn, num) {
    var args = S.makeArray(arguments), types = args[2 + num];
    if(types && typeof types === "object") {
      S.each(types, function(value, type) {
        var args2 = [].concat(args);
        args2.splice(0, 2);
        args2[num] = type;
        args2[num + 1] = value;
        fn.apply(null, args2)
      })
    }else {
      splitAndRun(types, function(type) {
        var args2 = [].concat(args);
        args2.splice(0, 2);
        args2[num] = type;
        fn.apply(null, args2)
      })
    }
  }, fillGroupsForEvent:function(type, eventData) {
    var typedGroups = getTypedGroups(type), _ksGroups = typedGroups[1];
    if(_ksGroups) {
      _ksGroups = getGroupsRe(_ksGroups);
      eventData._ksGroups = _ksGroups
    }
    eventData.type = typedGroups[0]
  }, getGroupsRe:getGroupsRe = function(groups) {
    return new RegExp(groups.split(".").join(".*\\.") + "(?:\\.|$)")
  }}
});
KISSY.add("event/base/object", [], function(S, undefined) {
  var returnFalse = function() {
    return false
  }, returnTrue = function() {
    return true
  };
  function EventObject() {
    var self = this;
    self.timeStamp = S.now();
    self.target = undefined;
    self.currentTarget = undefined
  }
  EventObject.prototype = {constructor:EventObject, isDefaultPrevented:returnFalse, isPropagationStopped:returnFalse, isImmediatePropagationStopped:returnFalse, preventDefault:function() {
    this.isDefaultPrevented = returnTrue
  }, stopPropagation:function() {
    this.isPropagationStopped = returnTrue
  }, stopImmediatePropagation:function() {
    var self = this;
    self.isImmediatePropagationStopped = returnTrue;
    self.stopPropagation()
  }, halt:function(immediate) {
    var self = this;
    if(immediate) {
      self.stopImmediatePropagation()
    }else {
      self.stopPropagation()
    }
    self.preventDefault()
  }};
  return EventObject
});
KISSY.add("event/base/observer", [], function(S, undefined) {
  function Observer(cfg) {
    S.mix(this, cfg)
  }
  Observer.prototype = {constructor:Observer, equals:function(s2) {
    var s1 = this;
    return!!S.reduce(s1.keys, function(v, k) {
      return v && s1[k] === s2[k]
    }, 1)
  }, simpleNotify:function(event, ce) {
    var ret, self = this;
    ret = self.fn.call(self.context || ce.currentTarget, event, self.data);
    if(self.once) {
      ce.removeObserver(self)
    }
    return ret
  }, notifyInternal:function(event, ce) {
    var ret = this.simpleNotify(event, ce);
    if(ret === false) {
      event.halt()
    }
    return ret
  }, notify:function(event, ce) {
    var self = this, _ksGroups = event._ksGroups;
    if(_ksGroups && (!self.groups || !self.groups.match(_ksGroups))) {
      return undefined
    }
    return self.notifyInternal(event, ce)
  }};
  return Observer
});
KISSY.add("event/base/observable", [], function(S) {
  function Observable(cfg) {
    var self = this;
    self.currentTarget = null;
    S.mix(self, cfg);
    self.reset()
  }
  Observable.prototype = {constructor:Observable, hasObserver:function() {
    return!!this.observers.length
  }, reset:function() {
    var self = this;
    self.observers = []
  }, removeObserver:function(observer) {
    var self = this, i, observers = self.observers, len = observers.length;
    for(i = 0;i < len;i++) {
      if(observers[i] === observer) {
        observers.splice(i, 1);
        break
      }
    }
    self.checkMemory()
  }, checkMemory:function() {
  }, findObserver:function(observer) {
    var observers = this.observers, i;
    for(i = observers.length - 1;i >= 0;--i) {
      if(observer.equals(observers[i])) {
        return i
      }
    }
    return-1
  }};
  return Observable
});
KISSY.add("event/base", ["./base/utils", "./base/object", "./base/observer", "./base/observable"], function(S, require) {
  var Utils = require("./base/utils");
  var Object = require("./base/object");
  var Observer = require("./base/observer");
  var Observable = require("./base/observable");
  return{Utils:Utils, Object:Object, Observer:Observer, Observable:Observable}
});

/*
Copyright 2013, KISSY v1.42
MIT Licensed
build time: Dec 4 22:16
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 event/dom/shake
*/

KISSY.add("event/dom/shake", ["event/dom/base"], function(S, require) {
  var DomEvent = require("event/dom/base");
  var Special = DomEvent.Special, start = 5, enough = 20, shaking = 0, lastX, lastY, lastZ, max = Math.max, abs = Math.abs, win = S.Env.host, devicemotion = "devicemotion", checkShake = S.buffer(function() {
    if(shaking) {
      DomEvent.fireHandler(win, "shake", {accelerationIncludingGravity:{x:lastX, y:lastY, z:lastZ}});
      clear()
    }
  }, 250);
  Special.shake = {setup:function() {
    if(this !== win) {
      return
    }
    win.addEventListener(devicemotion, shake, false)
  }, tearDown:function() {
    if(this !== win) {
      return
    }
    checkShake.stop();
    clear();
    win.removeEventListener(devicemotion, shake, false)
  }};
  function clear() {
    lastX = undefined;
    shaking = 0
  }
  function shake(e) {
    var accelerationIncludingGravity = e.accelerationIncludingGravity, x = accelerationIncludingGravity.x, y = accelerationIncludingGravity.y, z = accelerationIncludingGravity.z, diff;
    if(lastX !== undefined) {
      diff = max(abs(x - lastX), abs(y - lastY), abs(z - lastZ));
      if(diff > start) {
        checkShake()
      }
      if(diff > enough) {
        shaking = 1
      }
    }
    lastX = x;
    lastY = y;
    lastZ = z
  }
});

/*
Copyright 2013, KISSY v1.42
MIT Licensed
build time: Dec 4 22:15
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 event/dom/focusin
*/

KISSY.add("event/dom/focusin", ["event/dom/base"], function(S, require) {
  var DomEvent = require("event/dom/base");
  var Special = DomEvent.Special;
  S.each([{name:"focusin", fix:"focus"}, {name:"focusout", fix:"blur"}], function(o) {
    var key = S.guid("attaches_" + S.now() + "_");
    Special[o.name] = {setup:function() {
      var doc = this.ownerDocument || this;
      if(!(key in doc)) {
        doc[key] = 0
      }
      doc[key] += 1;
      if(doc[key] === 1) {
        doc.addEventListener(o.fix, handler, true)
      }
    }, tearDown:function() {
      var doc = this.ownerDocument || this;
      doc[key] -= 1;
      if(doc[key] === 0) {
        doc.removeEventListener(o.fix, handler, true)
      }
    }};
    function handler(event) {
      var target = event.target;
      return DomEvent.fire(target, o.name)
    }
  });
  return DomEvent
});

/*
Copyright 2013, KISSY v1.42
MIT Licensed
build time: Dec 4 22:15
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 event/custom/observer
 event/custom/object
 event/custom/observable
 event/custom/target
 event/custom
*/

KISSY.add("event/custom/observer", ["event/base"], function(S, require) {
  var BaseEvent = require("event/base");
  function CustomEventObserver() {
    CustomEventObserver.superclass.constructor.apply(this, arguments)
  }
  S.extend(CustomEventObserver, BaseEvent.Observer, {keys:["fn", "context", "groups"]});
  return CustomEventObserver
});
KISSY.add("event/custom/object", ["event/base"], function(S, require) {
  var BaseEvent = require("event/base");
  function CustomEventObject(data) {
    CustomEventObject.superclass.constructor.call(this);
    S.mix(this, data)
  }
  S.extend(CustomEventObject, BaseEvent.Object);
  return CustomEventObject
});
KISSY.add("event/custom/observable", ["event/base", "./observer", "./object"], function(S, require) {
  var BaseEvent = require("event/base");
  var CustomEventObserver = require("./observer");
  var CustomEventObject = require("./object");
  var Utils = BaseEvent.Utils;
  function CustomEventObservable() {
    var self = this;
    CustomEventObservable.superclass.constructor.apply(self, arguments);
    self.defaultFn = null;
    self.defaultTargetOnly = false;
    self.bubbles = true
  }
  S.extend(CustomEventObservable, BaseEvent.Observable, {on:function(cfg) {
    var observer = new CustomEventObserver(cfg);
    if(S.Config.debug) {
      if(!observer.fn) {
        S.error("lack event handler for " + this.type)
      }
    }
    if(this.findObserver(observer) === -1) {
      this.observers.push(observer)
    }
  }, fire:function(eventData) {
    eventData = eventData || {};
    var self = this, bubbles = self.bubbles, currentTarget = self.currentTarget, parents, parentsLen, type = self.type, defaultFn = self.defaultFn, i, customEventObject = eventData, gRet, ret;
    eventData.type = type;
    if(!(customEventObject instanceof CustomEventObject)) {
      customEventObject.target = currentTarget;
      customEventObject = new CustomEventObject(customEventObject)
    }
    customEventObject.currentTarget = currentTarget;
    ret = self.notify(customEventObject);
    if(gRet !== false && ret !== undefined) {
      gRet = ret
    }
    if(bubbles && !customEventObject.isPropagationStopped()) {
      parents = currentTarget.getTargets();
      parentsLen = parents && parents.length || 0;
      for(i = 0;i < parentsLen && !customEventObject.isPropagationStopped();i++) {
        ret = parents[i].fire(type, customEventObject);
        if(gRet !== false && ret !== undefined) {
          gRet = ret
        }
      }
    }
    if(defaultFn && !customEventObject.isDefaultPrevented()) {
      var target = customEventObject.target, lowestCustomEventObservable = target.getCustomEventObservable(customEventObject.type);
      if(!self.defaultTargetOnly && !lowestCustomEventObservable.defaultTargetOnly || currentTarget === target) {
        gRet = defaultFn.call(currentTarget, customEventObject)
      }
    }
    return gRet
  }, notify:function(event) {
    var observers = [].concat(this.observers), ret, gRet, len = observers.length, i;
    for(i = 0;i < len && !event.isImmediatePropagationStopped();i++) {
      ret = observers[i].notify(event, this);
      if(gRet !== false && ret !== undefined) {
        gRet = ret
      }
    }
    return gRet
  }, detach:function(cfg) {
    var groupsRe, self = this, fn = cfg.fn, context = cfg.context, currentTarget = self.currentTarget, observers = self.observers, groups = cfg.groups;
    if(!observers.length) {
      return
    }
    if(groups) {
      groupsRe = Utils.getGroupsRe(groups)
    }
    var i, j, t, observer, observerContext, len = observers.length;
    if(fn || groupsRe) {
      context = context || currentTarget;
      for(i = 0, j = 0, t = [];i < len;++i) {
        observer = observers[i];
        observerContext = observer.context || currentTarget;
        if(context !== observerContext || fn && fn !== observer.fn || groupsRe && !observer.groups.match(groupsRe)) {
          t[j++] = observer
        }
      }
      self.observers = t
    }else {
      self.reset()
    }
  }});
  return CustomEventObservable
});
KISSY.add("event/custom/target", ["event/base", "./observable"], function(S, require) {
  var BaseEvent = require("event/base");
  var CustomEventObservable = require("./observable");
  var Utils = BaseEvent.Utils, splitAndRun = Utils.splitAndRun, KS_BUBBLE_TARGETS = "__~ks_bubble_targets";
  var KS_CUSTOM_EVENTS = "__~ks_custom_events";
  return{isTarget:1, getCustomEventObservable:function(type, create) {
    var target = this, customEvent, customEventObservables = target.getCustomEvents();
    customEvent = customEventObservables && customEventObservables[type];
    if(!customEvent && create) {
      customEvent = customEventObservables[type] = new CustomEventObservable({currentTarget:target, type:type})
    }
    return customEvent
  }, fire:function(type, eventData) {
    var self = this, ret, targets = self.getTargets(), hasTargets = targets && targets.length;
    eventData = eventData || {};
    splitAndRun(type, function(type) {
      var r2, customEventObservable;
      Utils.fillGroupsForEvent(type, eventData);
      type = eventData.type;
      customEventObservable = self.getCustomEventObservable(type);
      if(!customEventObservable && !hasTargets) {
        return
      }
      if(customEventObservable) {
        if(!customEventObservable.hasObserver() && !customEventObservable.defaultFn) {
          if(customEventObservable.bubbles && !hasTargets || !customEventObservable.bubbles) {
            return
          }
        }
      }else {
        customEventObservable = new CustomEventObservable({currentTarget:self, type:type})
      }
      r2 = customEventObservable.fire(eventData);
      if(ret !== false && r2 !== undefined) {
        ret = r2
      }
    });
    return ret
  }, publish:function(type, cfg) {
    var customEventObservable, self = this;
    splitAndRun(type, function(t) {
      customEventObservable = self.getCustomEventObservable(t, true);
      S.mix(customEventObservable, cfg)
    });
    return self
  }, addTarget:function(anotherTarget) {
    var self = this, targets = self.getTargets();
    if(!S.inArray(anotherTarget, targets)) {
      targets.push(anotherTarget)
    }
    return self
  }, removeTarget:function(anotherTarget) {
    var self = this, targets = self.getTargets(), index = S.indexOf(anotherTarget, targets);
    if(index !== -1) {
      targets.splice(index, 1)
    }
    return self
  }, getTargets:function() {
    return this[KS_BUBBLE_TARGETS] || (this[KS_BUBBLE_TARGETS] = [])
  }, getCustomEvents:function() {
    return this[KS_CUSTOM_EVENTS] || (this[KS_CUSTOM_EVENTS] = {})
  }, on:function(type, fn, context) {
    var self = this;
    Utils.batchForType(function(type, fn, context) {
      var cfg = Utils.normalizeParam(type, fn, context), customEvent;
      type = cfg.type;
      customEvent = self.getCustomEventObservable(type, true);
      if(customEvent) {
        customEvent.on(cfg)
      }
    }, 0, type, fn, context);
    return self
  }, detach:function(type, fn, context) {
    var self = this;
    Utils.batchForType(function(type, fn, context) {
      var cfg = Utils.normalizeParam(type, fn, context), customEvents, customEvent;
      type = cfg.type;
      if(type) {
        customEvent = self.getCustomEventObservable(type, true);
        if(customEvent) {
          customEvent.detach(cfg)
        }
      }else {
        customEvents = self.getCustomEvents();
        S.each(customEvents, function(customEvent) {
          customEvent.detach(cfg)
        })
      }
    }, 0, type, fn, context);
    return self
  }}
});
KISSY.add("event/custom", ["./custom/target"], function(S, require) {
  var Target = require("./custom/target");
  return{Target:Target, global:S.mix({}, Target)}
});

/*
Copyright 2013, KISSY v1.42
MIT Licensed
build time: Dec 9 22:41
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 io/form-serializer
 io/base
 io/xhr-transport-base
 io/xdr-flash-transport
 io/sub-domain-transport
 io/xhr-transport
 io/script-transport
 io/jsonp
 io/form
 io/iframe-transport
 io/methods
 io
*/

KISSY.add("io/form-serializer", ["dom"], function(S, require) {
  var Dom = require("dom");
  var rselectTextarea = /^(?:select|textarea)/i, rCRLF = /\r?\n/g, FormSerializer, rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i;
  function normalizeCRLF(v) {
    return v.replace(rCRLF, "\r\n")
  }
  FormSerializer = {serialize:function(forms, serializeArray) {
    return S.param(FormSerializer.getFormData(forms), undefined, undefined, serializeArray || false)
  }, getFormData:function(forms) {
    var elements = [], data = {};
    S.each(Dom.query(forms), function(el) {
      var subs = el.elements ? S.makeArray(el.elements) : [el];
      elements.push.apply(elements, subs)
    });
    elements = S.filter(elements, function(el) {
      return el.name && !el.disabled && (el.checked || rselectTextarea.test(el.nodeName) || rinput.test(el.type))
    });
    S.each(elements, function(el) {
      var val = Dom.val(el), vs;
      if(val === null) {
        return
      }
      if(S.isArray(val)) {
        val = S.map(val, normalizeCRLF)
      }else {
        val = normalizeCRLF(val)
      }
      vs = data[el.name];
      if(!vs) {
        data[el.name] = val;
        return
      }
      if(vs && !S.isArray(vs)) {
        vs = data[el.name] = [vs]
      }
      vs.push.apply(vs, S.makeArray(val))
    });
    return data
  }};
  return FormSerializer
});
KISSY.add("io/base", ["event/custom", "promise"], function(S, require) {
  var CustomEvent = require("event/custom"), Promise = require("promise");
  var rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|widget)$/, rspace = /\s+/, mirror = function(s) {
    return s
  }, rnoContent = /^(?:GET|HEAD)$/, win = S.Env.host, location = win.location || {}, simulatedLocation = new S.Uri(location.href), isLocal = simulatedLocation && rlocalProtocol.test(simulatedLocation.getScheme()), transports = {}, defaultConfig = {type:"GET", contentType:"application/x-www-form-urlencoded; charset=UTF-8", async:true, serializeArray:true, processData:true, accepts:{xml:"application/xml, text/xml", html:"text/html", text:"text/plain", json:"application/json, text/javascript", "*":"*/*"}, 
  converters:{text:{json:S.parseJson, html:mirror, text:mirror, xml:S.parseXML}}, headers:{"X-Requested-With":"XMLHttpRequest"}, contents:{xml:/xml/, html:/html/, json:/json/}};
  defaultConfig.converters.html = defaultConfig.converters.text;
  function setUpConfig(c) {
    var context = c.context;
    delete c.context;
    c = S.mix(S.clone(defaultConfig), c, {deep:true});
    c.context = context || c;
    var data, uri, type = c.type, dataType = c.dataType;
    uri = c.uri = simulatedLocation.resolve(c.url);
    c.uri.setQuery("");
    if(!("crossDomain" in c)) {
      c.crossDomain = !c.uri.isSameOriginAs(simulatedLocation)
    }
    type = c.type = type.toUpperCase();
    c.hasContent = !rnoContent.test(type);
    if(c.processData && (data = c.data) && typeof data !== "string") {
      c.data = S.param(data, undefined, undefined, c.serializeArray)
    }
    dataType = c.dataType = S.trim(dataType || "*").split(rspace);
    if(!("cache" in c) && S.inArray(dataType[0], ["script", "jsonp"])) {
      c.cache = false
    }
    if(!c.hasContent) {
      if(c.data) {
        uri.query.add(S.unparam(c.data))
      }
      if(c.cache === false) {
        uri.query.set("_ksTS", S.now() + "_" + S.guid())
      }
    }
    return c
  }
  function IO(c) {
    var self = this;
    if(!(self instanceof IO)) {
      return new IO(c)
    }
    Promise.call(self);
    c = setUpConfig(c);
    S.mix(self, {responseData:null, config:c || {}, timeoutTimer:null, responseText:null, responseXML:null, responseHeadersString:"", responseHeaders:null, requestHeaders:{}, readyState:0, state:0, statusText:null, status:0, transport:null});
    Promise.Defer(self);
    var TransportConstructor, transport;
    IO.fire("start", {ajaxConfig:c, io:self});
    TransportConstructor = transports[c.dataType[0]] || transports["*"];
    transport = new TransportConstructor(self);
    self.transport = transport;
    if(c.contentType) {
      self.setRequestHeader("Content-Type", c.contentType)
    }
    var dataType = c.dataType[0], i, timeout = c.timeout, context = c.context, headers = c.headers, accepts = c.accepts;
    self.setRequestHeader("Accept", dataType && accepts[dataType] ? accepts[dataType] + (dataType === "*" ? "" : ", */*; q=0.01") : accepts["*"]);
    for(i in headers) {
      self.setRequestHeader(i, headers[i])
    }
    if(c.beforeSend && c.beforeSend.call(context, self, c) === false) {
      return self
    }
    self.readyState = 1;
    IO.fire("send", {ajaxConfig:c, io:self});
    if(c.async && timeout > 0) {
      self.timeoutTimer = setTimeout(function() {
        self.abort("timeout")
      }, timeout * 1E3)
    }
    try {
      self.state = 1;
      transport.send()
    }catch(e) {
      if(self.state < 2) {
        S.log(e.stack || e, "error");
        setTimeout(function() {
          throw e;
        }, 0);
        self._ioReady(-1, e.message)
      }else {
        S.error(e)
      }
    }
    return self
  }
  S.mix(IO, CustomEvent.Target);
  S.mix(IO, {isLocal:isLocal, setupConfig:function(setting) {
    S.mix(defaultConfig, setting, {deep:true})
  }, setupTransport:function(name, fn) {
    transports[name] = fn
  }, getTransport:function(name) {
    return transports[name]
  }, getConfig:function() {
    return defaultConfig
  }});
  return IO
});
KISSY.add("io/xhr-transport-base", ["./base"], function(S, require) {
  var IO = require("./base");
  var logger = S.getLogger("s/io");
  var OK_CODE = 200, win = S.Env.host, XDomainRequest_ = S.UA.ieMode > 7 && win.XDomainRequest, NO_CONTENT_CODE = 204, NOT_FOUND_CODE = 404, NO_CONTENT_CODE2 = 1223, XhrTransportBase = {proto:{}}, lastModifiedCached = {}, eTagCached = {};
  IO.__lastModifiedCached = lastModifiedCached;
  IO.__eTagCached = eTagCached;
  function createStandardXHR(_, refWin) {
    try {
      return new (refWin || win).XMLHttpRequest
    }catch(e) {
    }
    return undefined
  }
  function createActiveXHR(_, refWin) {
    try {
      return new (refWin || win).ActiveXObject("Microsoft.XMLHTTP")
    }catch(e) {
    }
    return undefined
  }
  XhrTransportBase.nativeXhr = win.ActiveXObject ? function(crossDomain, refWin) {
    if(!supportCORS && crossDomain && XDomainRequest_) {
      return new XDomainRequest_
    }
    return!IO.isLocal && createStandardXHR(crossDomain, refWin) || createActiveXHR(crossDomain, refWin)
  } : createStandardXHR;
  XhrTransportBase.XDomainRequest_ = XDomainRequest_;
  var supportCORS = XhrTransportBase.supportCORS = "withCredentials" in XhrTransportBase.nativeXhr();
  function isInstanceOfXDomainRequest(xhr) {
    return XDomainRequest_ && xhr instanceof XDomainRequest_
  }
  function getIfModifiedKey(c) {
    var ifModified = c.ifModified, ifModifiedKey;
    if(ifModified) {
      ifModifiedKey = c.uri;
      if(c.cache === false) {
        ifModifiedKey = ifModifiedKey.clone();
        ifModifiedKey.query.remove("_ksTS")
      }
      ifModifiedKey = ifModifiedKey.toString()
    }
    return ifModifiedKey
  }
  S.mix(XhrTransportBase.proto, {sendInternal:function() {
    var self = this, io = self.io, c = io.config, nativeXhr = self.nativeXhr, files = c.files, type = files ? "post" : c.type, async = c.async, username, mimeType = io.mimeType, requestHeaders = io.requestHeaders || {}, url = io._getUrlForSend(), xhrFields, ifModifiedKey = getIfModifiedKey(c), cacheValue, i;
    if(ifModifiedKey) {
      if(cacheValue = lastModifiedCached[ifModifiedKey]) {
        requestHeaders["If-Modified-Since"] = cacheValue
      }
      if(cacheValue = eTagCached[ifModifiedKey]) {
        requestHeaders["If-None-Match"] = cacheValue
      }
    }
    if(username = c.username) {
      nativeXhr.open(type, url, async, username, c.password)
    }else {
      nativeXhr.open(type, url, async)
    }
    xhrFields = c.xhrFields || {};
    if("withCredentials" in xhrFields) {
      if(!supportCORS) {
        delete xhrFields.withCredentials
      }
    }
    for(i in xhrFields) {
      try {
        nativeXhr[i] = xhrFields[i]
      }catch(e) {
        logger.error(e)
      }
    }
    if(mimeType && nativeXhr.overrideMimeType) {
      nativeXhr.overrideMimeType(mimeType)
    }
    var xRequestHeader = requestHeaders["X-Requested-With"];
    if(xRequestHeader === false) {
      delete requestHeaders["X-Requested-With"]
    }
    if(typeof nativeXhr.setRequestHeader !== "undefined") {
      for(i in requestHeaders) {
        nativeXhr.setRequestHeader(i, requestHeaders[i])
      }
    }
    var sendContent = c.hasContent && c.data || null;
    if(files) {
      var originalSentContent = sendContent, data = {};
      if(originalSentContent) {
        data = S.unparam(originalSentContent)
      }
      data = S.mix(data, files);
      sendContent = new FormData;
      S.each(data, function(vs, k) {
        if(S.isArray(vs)) {
          S.each(vs, function(v) {
            sendContent.append(k + (c.serializeArray ? "[]" : ""), v)
          })
        }else {
          sendContent.append(k, vs)
        }
      })
    }
    nativeXhr.send(sendContent);
    if(!async || nativeXhr.readyState === 4) {
      self._callback()
    }else {
      if(isInstanceOfXDomainRequest(nativeXhr)) {
        nativeXhr.onload = function() {
          nativeXhr.readyState = 4;
          nativeXhr.status = 200;
          self._callback()
        };
        nativeXhr.onerror = function() {
          nativeXhr.readyState = 4;
          nativeXhr.status = 500;
          self._callback()
        }
      }else {
        nativeXhr.onreadystatechange = function() {
          self._callback()
        }
      }
    }
  }, abort:function() {
    this._callback(0, 1)
  }, _callback:function(event, abort) {
    var self = this, nativeXhr = self.nativeXhr, io = self.io, ifModifiedKey, lastModified, eTag, statusText, xml, c = io.config;
    try {
      if(abort || nativeXhr.readyState === 4) {
        if(isInstanceOfXDomainRequest(nativeXhr)) {
          nativeXhr.onerror = S.noop;
          nativeXhr.onload = S.noop
        }else {
          nativeXhr.onreadystatechange = S.noop
        }
        if(abort) {
          if(nativeXhr.readyState !== 4) {
            nativeXhr.abort()
          }
        }else {
          ifModifiedKey = getIfModifiedKey(c);
          var status = nativeXhr.status;
          if(!isInstanceOfXDomainRequest(nativeXhr)) {
            io.responseHeadersString = nativeXhr.getAllResponseHeaders()
          }
          if(ifModifiedKey) {
            lastModified = nativeXhr.getResponseHeader("Last-Modified");
            eTag = nativeXhr.getResponseHeader("ETag");
            if(lastModified) {
              lastModifiedCached[ifModifiedKey] = lastModified
            }
            if(eTag) {
              eTagCached[eTag] = eTag
            }
          }
          xml = nativeXhr.responseXML;
          if(xml && xml.documentElement) {
            io.responseXML = xml
          }
          var text = io.responseText = nativeXhr.responseText;
          if(c.files && text) {
            var bodyIndex, lastBodyIndex;
            if((bodyIndex = text.indexOf("<body>")) !== -1) {
              lastBodyIndex = text.lastIndexOf("</body>");
              if(lastBodyIndex === -1) {
                lastBodyIndex = text.length
              }
              text = text.slice(bodyIndex + 6, lastBodyIndex)
            }
            io.responseText = S.unEscapeHtml(text)
          }
          try {
            statusText = nativeXhr.statusText
          }catch(e) {
            logger.error("xhr statusText error: ");
            logger.error(e);
            statusText = ""
          }
          if(!status && IO.isLocal && !c.crossDomain) {
            status = io.responseText ? OK_CODE : NOT_FOUND_CODE
          }else {
            if(status === NO_CONTENT_CODE2) {
              status = NO_CONTENT_CODE
            }
          }
          io._ioReady(status, statusText)
        }
      }
    }catch(e) {
      S.log(e.stack || e, "error");
      setTimeout(function() {
        throw e;
      }, 0);
      nativeXhr.onreadystatechange = S.noop;
      if(!abort) {
        io._ioReady(-1, e)
      }
    }
  }});
  return XhrTransportBase
});
KISSY.add("io/xdr-flash-transport", ["./base", "dom"], function(S, require) {
  var IO = require("./base"), Dom = require("dom");
  var logger = S.getLogger("s/io");
  var maps = {}, ID = "io_swf", flash, doc = S.Env.host.document, init = false;
  function _swf(uri, _, uid) {
    if(init) {
      return
    }
    init = true;
    var o = '<object id="' + ID + '" type="application/x-shockwave-flash" data="' + uri + '" width="0" height="0">' + '<param name="movie" value="' + uri + '" />' + '<param name="FlashVars" value="yid=' + _ + "&uid=" + uid + '&host=KISSY.IO" />' + '<param name="allowScriptAccess" value="always" />' + "</object>", c = doc.createElement("div");
    Dom.prepend(c, doc.body || doc.documentElement);
    c.innerHTML = o
  }
  function XdrFlashTransport(io) {
    logger.info("use XdrFlashTransport for: " + io.config.url);
    this.io = io
  }
  S.augment(XdrFlashTransport, {send:function() {
    var self = this, io = self.io, c = io.config, xdr = c.xdr || {};
    _swf(xdr.src || S.Config.base + "io/assets/io.swf", 1, 1);
    if(!flash) {
      setTimeout(function() {
        self.send()
      }, 200);
      return
    }
    self._uid = S.guid();
    maps[self._uid] = self;
    flash.send(io._getUrlForSend(), {id:self._uid, uid:self._uid, method:c.type, data:c.hasContent && c.data || {}})
  }, abort:function() {
    flash.abort(this._uid)
  }, _xdrResponse:function(e, o) {
    var self = this, ret, id = o.id, responseText, c = o.c, io = self.io;
    if(c && (responseText = c.responseText)) {
      io.responseText = decodeURI(responseText)
    }
    switch(e) {
      case "success":
        ret = {status:200, statusText:"success"};
        delete maps[id];
        break;
      case "abort":
        delete maps[id];
        break;
      case "timeout":
      ;
      case "transport error":
      ;
      case "failure":
        delete maps[id];
        ret = {status:"status" in c ? c.status : 500, statusText:c.statusText || e};
        break
    }
    if(ret) {
      io._ioReady(ret.status, ret.statusText)
    }
  }});
  IO.applyTo = function(_, cmd, args) {
    var cmds = cmd.split(".").slice(1), func = IO;
    S.each(cmds, function(c) {
      func = func[c]
    });
    func.apply(null, args)
  };
  IO.xdrReady = function() {
    flash = doc.getElementById(ID)
  };
  IO.xdrResponse = function(e, o) {
    var xhr = maps[o.uid];
    if(xhr) {
      xhr._xdrResponse(e, o)
    }
  };
  return XdrFlashTransport
});
KISSY.add("io/sub-domain-transport", ["event/dom", "dom", "./xhr-transport-base"], function(S, require) {
  var Event = require("event/dom"), Dom = require("dom"), XhrTransportBase = require("./xhr-transport-base");
  var logger = S.getLogger("s/io");
  var PROXY_PAGE = "/sub_domain_proxy.html", doc = S.Env.host.document, iframeMap = {};
  function SubDomainTransport(io) {
    var self = this, c = io.config;
    self.io = io;
    c.crossDomain = false;
    logger.info("use SubDomainTransport for: " + c.url)
  }
  S.augment(SubDomainTransport, XhrTransportBase.proto, {send:function() {
    var self = this, c = self.io.config, uri = c.uri, hostname = uri.getHostname(), iframe, iframeUri, iframeDesc = iframeMap[hostname];
    var proxy = PROXY_PAGE;
    if(c.xdr && c.xdr.subDomain && c.xdr.subDomain.proxy) {
      proxy = c.xdr.subDomain.proxy
    }
    if(iframeDesc && iframeDesc.ready) {
      self.nativeXhr = XhrTransportBase.nativeXhr(0, iframeDesc.iframe.contentWindow);
      if(self.nativeXhr) {
        self.sendInternal()
      }else {
        S.error("document.domain not set correctly!")
      }
      return
    }
    if(!iframeDesc) {
      iframeDesc = iframeMap[hostname] = {};
      iframe = iframeDesc.iframe = doc.createElement("iframe");
      Dom.css(iframe, {position:"absolute", left:"-9999px", top:"-9999px"});
      Dom.prepend(iframe, doc.body || doc.documentElement);
      iframeUri = new S.Uri;
      iframeUri.setScheme(uri.getScheme());
      iframeUri.setPort(uri.getPort());
      iframeUri.setHostname(hostname);
      iframeUri.setPath(proxy);
      iframe.src = iframeUri.toString()
    }else {
      iframe = iframeDesc.iframe
    }
    Event.on(iframe, "load", _onLoad, self)
  }});
  function _onLoad() {
    var self = this, c = self.io.config, uri = c.uri, hostname = uri.getHostname(), iframeDesc = iframeMap[hostname];
    iframeDesc.ready = 1;
    Event.detach(iframeDesc.iframe, "load", _onLoad, self);
    self.send()
  }
  return SubDomainTransport
});
KISSY.add("io/xhr-transport", ["./base", "./xhr-transport-base", "./xdr-flash-transport", "./sub-domain-transport"], function(S, require) {
  var IO = require("./base"), XhrTransportBase = require("./xhr-transport-base"), XdrFlashTransport = require("./xdr-flash-transport"), SubDomainTransport = require("./sub-domain-transport");
  var logger = S.getLogger("s/io");
  var win = S.Env.host, doc = win.document, XDomainRequest_ = XhrTransportBase.XDomainRequest_;
  function isSubDomain(hostname) {
    return doc.domain && S.endsWith(hostname, doc.domain)
  }
  function XhrTransport(io) {
    var c = io.config, crossDomain = c.crossDomain, self = this, xhr, xdrCfg = c.xdr || {}, subDomain = xdrCfg.subDomain = xdrCfg.subDomain || {};
    self.io = io;
    if(crossDomain && !XhrTransportBase.supportCORS) {
      if(isSubDomain(c.uri.getHostname())) {
        if(subDomain.proxy !== false) {
          return new SubDomainTransport(io)
        }
      }
      if(String(xdrCfg.use) === "flash" || !XDomainRequest_) {
        return new XdrFlashTransport(io)
      }
    }
    xhr = self.nativeXhr = XhrTransportBase.nativeXhr(crossDomain);
    var msg = "crossDomain: " + crossDomain + ", use " + (XDomainRequest_ && xhr instanceof XDomainRequest_ ? "XDomainRequest" : "XhrTransport") + " for: " + c.url;
    logger.debug(msg);
    return self
  }
  S.augment(XhrTransport, XhrTransportBase.proto, {send:function() {
    this.sendInternal()
  }});
  IO.setupTransport("*", XhrTransport);
  return IO
});
KISSY.add("io/script-transport", ["./base"], function(S, require) {
  var IO = require("./base");
  var logger = S.getLogger("s/io");
  var OK_CODE = 200, ERROR_CODE = 500;
  IO.setupConfig({accepts:{script:"text/javascript, " + "application/javascript, " + "application/ecmascript, " + "application/x-ecmascript"}, contents:{script:/javascript|ecmascript/}, converters:{text:{script:function(text) {
    S.globalEval(text);
    return text
  }}}});
  function ScriptTransport(io) {
    var config = io.config, self = this;
    if(!config.crossDomain) {
      return new (IO.getTransport("*"))(io)
    }
    self.io = io;
    logger.info("use ScriptTransport for: " + config.url);
    return self
  }
  S.augment(ScriptTransport, {send:function() {
    var self = this, io = self.io, c = io.config;
    self.script = S.getScript(io._getUrlForSend(), {charset:c.scriptCharset, success:function() {
      self._callback("success")
    }, error:function() {
      self._callback("error")
    }})
  }, _callback:function(event, abort) {
    var self = this, script = self.script, io = self.io;
    if(!script) {
      return
    }
    self.script = undefined;
    if(abort) {
      return
    }
    if(event !== "error") {
      io._ioReady(OK_CODE, "success")
    }else {
      if(event === "error") {
        io._ioReady(ERROR_CODE, "script error")
      }
    }
  }, abort:function() {
    this._callback(0, 1)
  }});
  IO.setupTransport("script", ScriptTransport);
  return IO
});
KISSY.add("io/jsonp", ["./base"], function(S, require) {
  var IO = require("./base");
  var win = S.Env.host;
  IO.setupConfig({jsonp:"callback", jsonpCallback:function() {
    return S.guid("jsonp")
  }});
  IO.on("start", function(e) {
    var io = e.io, c = io.config, dataType = c.dataType;
    if(dataType[0] === "jsonp") {
      delete c.contentType;
      var response, cJsonpCallback = c.jsonpCallback, converters, jsonpCallback = typeof cJsonpCallback === "function" ? cJsonpCallback() : cJsonpCallback, previous = win[jsonpCallback];
      c.uri.query.set(c.jsonp, jsonpCallback);
      win[jsonpCallback] = function(r) {
        if(arguments.length > 1) {
          r = S.makeArray(arguments)
        }
        response = [r]
      };
      io.fin(function() {
        win[jsonpCallback] = previous;
        if(previous === undefined) {
          try {
            delete win[jsonpCallback]
          }catch(e) {
          }
        }else {
          if(response) {
            previous(response[0])
          }
        }
      });
      converters = c.converters;
      converters.script = converters.script || {};
      converters.script.json = function() {
        if(!response) {
          S.error(" not call jsonpCallback: " + jsonpCallback)
        }
        return response[0]
      };
      dataType.length = 2;
      dataType[0] = "script";
      dataType[1] = "json"
    }
  });
  return IO
});
KISSY.add("io/form", ["./base", "dom", "./form-serializer"], function(S, require) {
  var IO = require("./base");
  var Dom = require("dom");
  var FormSerializer = require("./form-serializer");
  var win = S.Env.host, slice = Array.prototype.slice, FormData = win.FormData;
  IO.on("start", function(e) {
    var io = e.io, form, d, dataType, formParam, data, c = io.config, tmpForm = c.form;
    if(tmpForm) {
      form = Dom.get(tmpForm);
      data = c.data;
      var isUpload = false;
      var files = {};
      var inputs = Dom.query("input", form);
      for(var i = 0, l = inputs.length;i < l;i++) {
        var input = inputs[i];
        if(input.type.toLowerCase() === "file") {
          isUpload = true;
          if(!FormData) {
            break
          }
          var selected = slice.call(input.files, 0);
          files[Dom.attr(input, "name")] = selected.length > 1 ? selected : selected[0] || null
        }
      }
      if(isUpload && FormData) {
        c.files = c.files || {};
        S.mix(c.files, files);
        delete c.contentType
      }
      if(!isUpload || FormData) {
        formParam = FormSerializer.getFormData(form);
        if(c.hasContent) {
          formParam = S.param(formParam, undefined, undefined, c.serializeArray);
          if(data) {
            c.data += "&" + formParam
          }else {
            c.data = formParam
          }
        }else {
          c.uri.query.add(formParam)
        }
      }else {
        dataType = c.dataType;
        d = dataType[0];
        if(d === "*") {
          d = "text"
        }
        dataType.length = 2;
        dataType[0] = "iframe";
        dataType[1] = d
      }
    }
  });
  return IO
});
KISSY.add("io/iframe-transport", ["dom", "./base", "event/dom"], function(S, require) {
  var Dom = require("dom"), IO = require("./base"), Event = require("event/dom");
  var logger = S.getLogger("s/io");
  var doc = S.Env.host.document, OK_CODE = 200, ERROR_CODE = 500, BREATH_INTERVAL = 30, iframeConverter = S.clone(IO.getConfig().converters.text);
  iframeConverter.json = function(str) {
    return S.parseJson(S.unEscapeHtml(str))
  };
  IO.setupConfig({converters:{iframe:iframeConverter, text:{iframe:function(text) {
    return text
  }}, xml:{iframe:function(xml) {
    return xml
  }}}});
  function createIframe(xhr) {
    var id = S.guid("io-iframe"), iframe, src = Dom.getEmptyIframeSrc();
    iframe = xhr.iframe = Dom.create("<iframe " + (src ? ' src="' + src + '" ' : "") + ' id="' + id + '"' + ' name="' + id + '"' + ' style="position:absolute;left:-9999px;top:-9999px;"/>');
    Dom.prepend(iframe, doc.body || doc.documentElement);
    return iframe
  }
  function addDataToForm(query, form, serializeArray) {
    var ret = [], isArray, vs, i, e;
    S.each(query, function(data, k) {
      isArray = S.isArray(data);
      vs = S.makeArray(data);
      for(i = 0;i < vs.length;i++) {
        e = doc.createElement("input");
        e.type = "hidden";
        e.name = k + (isArray && serializeArray ? "[]" : "");
        e.value = vs[i];
        Dom.append(e, form);
        ret.push(e)
      }
    });
    return ret
  }
  function removeFieldsFromData(fields) {
    Dom.remove(fields)
  }
  function IframeTransport(io) {
    this.io = io;
    logger.info("use IframeTransport for: " + io.config.url)
  }
  S.augment(IframeTransport, {send:function() {
    var self = this, io = self.io, c = io.config, fields, iframe, query, data = c.data, form = Dom.get(c.form);
    self.attrs = {target:Dom.attr(form, "target") || "", action:Dom.attr(form, "action") || "", encoding:Dom.attr(form, "encoding"), enctype:Dom.attr(form, "enctype"), method:Dom.attr(form, "method")};
    self.form = form;
    iframe = createIframe(io);
    Dom.attr(form, {target:iframe.id, action:io._getUrlForSend(), method:"post", enctype:"multipart/form-data", encoding:"multipart/form-data"});
    if(data) {
      query = S.unparam(data)
    }
    if(query) {
      fields = addDataToForm(query, form, c.serializeArray)
    }
    self.fields = fields;
    function go() {
      Event.on(iframe, "load error", self._callback, self);
      form.submit()
    }
    if(S.UA.ie === 6) {
      setTimeout(go, 0)
    }else {
      go()
    }
  }, _callback:function(event) {
    var self = this, form = self.form, io = self.io, eventType = event.type, iframeDoc, iframe = io.iframe;
    if(!iframe) {
      return
    }
    if(eventType === "abort" && S.UA.ie === 6) {
      setTimeout(function() {
        Dom.attr(form, self.attrs)
      }, 0)
    }else {
      Dom.attr(form, self.attrs)
    }
    removeFieldsFromData(this.fields);
    Event.detach(iframe);
    setTimeout(function() {
      Dom.remove(iframe)
    }, BREATH_INTERVAL);
    io.iframe = null;
    if(eventType === "load") {
      try {
        iframeDoc = iframe.contentWindow.document;
        if(iframeDoc && iframeDoc.body) {
          io.responseText = Dom.html(iframeDoc.body);
          if(S.startsWith(io.responseText, "<?xml")) {
            io.responseText = undefined
          }
        }
        if(iframeDoc && iframeDoc.XMLDocument) {
          io.responseXML = iframeDoc.XMLDocument
        }else {
          io.responseXML = iframeDoc
        }
        if(iframeDoc) {
          io._ioReady(OK_CODE, "success")
        }else {
          io._ioReady(ERROR_CODE, "parser error")
        }
      }catch(e) {
        io._ioReady(ERROR_CODE, "parser error")
      }
    }else {
      if(eventType === "error") {
        io._ioReady(ERROR_CODE, "error")
      }
    }
  }, abort:function() {
    this._callback({type:"abort"})
  }});
  IO.setupTransport("iframe", IframeTransport);
  return IO
});
KISSY.add("io/methods", ["promise", "./base"], function(S, require) {
  var Promise = require("promise"), IO = require("./base");
  var OK_CODE = 200, MULTIPLE_CHOICES = 300, NOT_MODIFIED = 304, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg;
  function handleResponseData(io) {
    var text = io.responseText, xml = io.responseXML, c = io.config, converts = c.converters, type, contentType, responseData, contents = c.contents, dataType = c.dataType;
    if(text || xml) {
      contentType = io.mimeType || io.getResponseHeader("Content-Type");
      while(dataType[0] === "*") {
        dataType.shift()
      }
      if(!dataType.length) {
        for(type in contents) {
          if(contents[type].test(contentType)) {
            if(dataType[0] !== type) {
              dataType.unshift(type)
            }
            break
          }
        }
      }
      dataType[0] = dataType[0] || "text";
      for(var dataTypeIndex = 0;dataTypeIndex < dataType.length;dataTypeIndex++) {
        if(dataType[dataTypeIndex] === "text" && text !== undefined) {
          responseData = text;
          break
        }else {
          if(dataType[dataTypeIndex] === "xml" && xml !== undefined) {
            responseData = xml;
            break
          }
        }
      }
      if(!responseData) {
        var rawData = {text:text, xml:xml};
        S.each(["text", "xml"], function(prevType) {
          var type = dataType[0], converter = converts[prevType] && converts[prevType][type];
          if(converter && rawData[prevType]) {
            dataType.unshift(prevType);
            responseData = prevType === "text" ? text : xml;
            return false
          }
          return undefined
        })
      }
    }
    var prevType = dataType[0];
    for(var i = 1;i < dataType.length;i++) {
      type = dataType[i];
      var converter = converts[prevType] && converts[prevType][type];
      if(!converter) {
        throw"no covert for " + prevType + " => " + type;
      }
      responseData = converter(responseData);
      prevType = type
    }
    io.responseData = responseData
  }
  S.extend(IO, Promise, {setRequestHeader:function(name, value) {
    var self = this;
    self.requestHeaders[name] = value;
    return self
  }, getAllResponseHeaders:function() {
    var self = this;
    return self.state === 2 ? self.responseHeadersString : null
  }, getResponseHeader:function(name) {
    var match, self = this, responseHeaders;
    name = name.toLowerCase();
    if(self.state === 2) {
      if(!(responseHeaders = self.responseHeaders)) {
        responseHeaders = self.responseHeaders = {};
        while(match = rheaders.exec(self.responseHeadersString)) {
          responseHeaders[match[1].toLowerCase()] = match[2]
        }
      }
      match = responseHeaders[name]
    }
    return match === undefined ? null : match
  }, overrideMimeType:function(type) {
    var self = this;
    if(!self.state) {
      self.mimeType = type
    }
    return self
  }, abort:function(statusText) {
    var self = this;
    statusText = statusText || "abort";
    if(self.transport) {
      self.transport.abort(statusText)
    }
    self._ioReady(0, statusText);
    return self
  }, getNativeXhr:function() {
    var transport = this.transport;
    if(transport) {
      return transport.nativeXhr
    }
    return null
  }, _ioReady:function(status, statusText) {
    var self = this;
    if(self.state === 2) {
      return
    }
    self.state = 2;
    self.readyState = 4;
    var isSuccess;
    if(status >= OK_CODE && status < MULTIPLE_CHOICES || status === NOT_MODIFIED) {
      if(status === NOT_MODIFIED) {
        statusText = "not modified";
        isSuccess = true
      }else {
        try {
          handleResponseData(self);
          statusText = "success";
          isSuccess = true
        }catch(e) {
          S.log(e.stack || e, "error");
          setTimeout(function() {
            throw e;
          }, 0);
          statusText = "parser error"
        }
      }
    }else {
      if(status < 0) {
        status = 0
      }
    }
    self.status = status;
    self.statusText = statusText;
    var defer = self.defer, config = self.config, timeoutTimer;
    if(timeoutTimer = self.timeoutTimer) {
      clearTimeout(timeoutTimer);
      self.timeoutTimer = 0
    }
    var handler = isSuccess ? "success" : "error", h, v = [self.responseData, statusText, self], context = config.context, eventObject = {ajaxConfig:config, io:self};
    if(h = config[handler]) {
      h.apply(context, v)
    }
    if(h = config.complete) {
      h.apply(context, v)
    }
    IO.fire(handler, eventObject);
    IO.fire("complete", eventObject);
    defer[isSuccess ? "resolve" : "reject"](v)
  }, _getUrlForSend:function() {
    var c = this.config, uri = c.uri, originalQuery = S.Uri.getComponents(c.url).query || "", url = uri.toString.call(uri, c.serializeArray);
    return url + (originalQuery ? (uri.query.has() ? "&" : "?") + originalQuery : originalQuery)
  }})
});
KISSY.add("io", ["io/form-serializer", "io/base", "io/xhr-transport", "io/script-transport", "io/jsonp", "io/form", "io/iframe-transport", "io/methods"], function(S, require) {
  var serializer = require("io/form-serializer"), IO = require("io/base");
  require("io/xhr-transport");
  require("io/script-transport");
  require("io/jsonp");
  require("io/form");
  require("io/iframe-transport");
  require("io/methods");
  function get(url, data, callback, dataType, type) {
    if(typeof data === "function") {
      dataType = callback;
      callback = data;
      data = undefined
    }
    return IO({type:type || "get", url:url, data:data, success:callback, dataType:dataType})
  }
  S.mix(IO, {serialize:serializer.serialize, get:get, post:function(url, data, callback, dataType) {
    if(typeof data === "function") {
      dataType = callback;
      callback = data;
      data = undefined
    }
    return get(url, data, callback, dataType, "post")
  }, jsonp:function(url, data, callback) {
    if(typeof data === "function") {
      callback = data;
      data = undefined
    }
    return get(url, data, callback, "jsonp")
  }, getScript:S.getScript, getJSON:function(url, data, callback) {
    if(typeof data === "function") {
      callback = data;
      data = undefined
    }
    return get(url, data, callback, "json")
  }, upload:function(url, form, data, callback, dataType) {
    if(typeof data === "function") {
      dataType = callback;
      callback = data;
      data = undefined
    }
    return IO({url:url, type:"post", dataType:dataType, form:form, data:data, success:callback})
  }});
  S.mix(S, {Ajax:IO, IO:IO, ajax:IO, io:IO, jsonp:IO.jsonp});
  return IO
});

/*
Copyright 2013, KISSY v1.42
MIT Licensed
build time: Dec 4 22:17
*/
/*
 Combined processedModules by KISSY Module Compiler: 

 promise
*/

KISSY.add("promise", [], function(S) {
  var logger = S.getLogger("s/promise");
  var PROMISE_VALUE = "__promise_value", processImmediate = S.setImmediate, PROMISE_PROGRESS_LISTENERS = "__promise_progress_listeners", PROMISE_PENDINGS = "__promise_pendings";
  function logError(str) {
    if(typeof console !== "undefined" && console.error) {
      console.error(str)
    }
  }
  function promiseWhen(promise, fulfilled, rejected) {
    if(promise instanceof Reject) {
      processImmediate(function() {
        rejected.call(promise, promise[PROMISE_VALUE])
      })
    }else {
      var v = promise[PROMISE_VALUE], pendings = promise[PROMISE_PENDINGS];
      if(pendings) {
        pendings.push([fulfilled, rejected])
      }else {
        if(isPromise(v)) {
          promiseWhen(v, fulfilled, rejected)
        }else {
          if(fulfilled) {
            processImmediate(function() {
              fulfilled.call(promise, v)
            })
          }
        }
      }
    }
  }
  function Defer(promise) {
    var self = this;
    if(!(self instanceof Defer)) {
      return new Defer(promise)
    }
    self.promise = promise || new Promise;
    self.promise.defer = self
  }
  Defer.prototype = {constructor:Defer, resolve:function(value) {
    var promise = this.promise, pendings;
    if(!(pendings = promise[PROMISE_PENDINGS])) {
      return null
    }
    promise[PROMISE_VALUE] = value;
    pendings = [].concat(pendings);
    promise[PROMISE_PENDINGS] = undefined;
    promise[PROMISE_PROGRESS_LISTENERS] = undefined;
    S.each(pendings, function(p) {
      promiseWhen(promise, p[0], p[1])
    });
    return value
  }, reject:function(reason) {
    return this.resolve(new Reject(reason))
  }, notify:function(message) {
    S.each(this.promise[PROMISE_PROGRESS_LISTENERS], function(listener) {
      processImmediate(function() {
        listener(message)
      })
    })
  }};
  function isPromise(obj) {
    return obj && obj instanceof Promise
  }
  function Promise(v) {
    var self = this;
    self[PROMISE_VALUE] = v;
    if(v === undefined) {
      self[PROMISE_PENDINGS] = [];
      self[PROMISE_PROGRESS_LISTENERS] = []
    }
  }
  Promise.prototype = {constructor:Promise, then:function(fulfilled, rejected, progressListener) {
    if(progressListener) {
      this.progress(progressListener)
    }
    return when(this, fulfilled, rejected)
  }, progress:function(progressListener) {
    if(this[PROMISE_PROGRESS_LISTENERS]) {
      this[PROMISE_PROGRESS_LISTENERS].push(progressListener)
    }
    return this
  }, fail:function(rejected) {
    return when(this, 0, rejected)
  }, fin:function(callback) {
    return when(this, function(value) {
      return callback(value, true)
    }, function(reason) {
      return callback(reason, false)
    })
  }, done:function(fulfilled, rejected) {
    var self = this, onUnhandledError = function(e) {
      S.log(e.stack || e, "error");
      setTimeout(function() {
        throw e;
      }, 0)
    }, promiseToHandle = fulfilled || rejected ? self.then(fulfilled, rejected) : self;
    promiseToHandle.fail(onUnhandledError)
  }, isResolved:function() {
    return isResolved(this)
  }, isRejected:function() {
    return isRejected(this)
  }};
  function Reject(reason) {
    if(reason instanceof Reject) {
      return reason
    }
    var self = this;
    Promise.apply(self, arguments);
    if(self[PROMISE_VALUE] instanceof Promise) {
      logger.error("assert.not(this.__promise_value instanceof promise) in Reject constructor")
    }
    return self
  }
  S.extend(Reject, Promise);
  function when(value, fulfilled, rejected) {
    var defer = new Defer, done = 0;
    function _fulfilled(value) {
      try {
        return fulfilled ? fulfilled.call(this, value) : value
      }catch(e) {
        logError(e.stack || e);
        return new Reject(e)
      }
    }
    function _rejected(reason) {
      try {
        return rejected ? rejected.call(this, reason) : new Reject(reason)
      }catch(e) {
        logError(e.stack || e);
        return new Reject(e)
      }
    }
    function finalFulfill(value) {
      if(done) {
        logger.error("already done at fulfilled");
        return
      }
      if(value instanceof Promise) {
        logger.error("assert.not(value instanceof Promise) in when");
        return
      }
      done = 1;
      defer.resolve(_fulfilled.call(this, value))
    }
    if(value instanceof Promise) {
      promiseWhen(value, finalFulfill, function(reason) {
        if(done) {
          logger.error("already done at rejected");
          return
        }
        done = 1;
        defer.resolve(_rejected.call(this, reason))
      })
    }else {
      finalFulfill(value)
    }
    return defer.promise
  }
  function isResolved(obj) {
    return!isRejected(obj) && isPromise(obj) && obj[PROMISE_PENDINGS] === undefined && (!isPromise(obj[PROMISE_VALUE]) || isResolved(obj[PROMISE_VALUE]))
  }
  function isRejected(obj) {
    return isPromise(obj) && obj[PROMISE_PENDINGS] === undefined && obj[PROMISE_VALUE] instanceof Reject
  }
  KISSY.Defer = Defer;
  KISSY.Promise = Promise;
  Promise.Defer = Defer;
  S.mix(Promise, {when:when, isPromise:isPromise, isResolved:isResolved, isRejected:isRejected, all:function(promises) {
    var count = promises.length;
    if(!count) {
      return null
    }
    var defer = new Defer;
    for(var i = 0;i < promises.length;i++) {
      (function(promise, i) {
        when(promise, function(value) {
          promises[i] = value;
          if(--count === 0) {
            defer.resolve(promises)
          }
        }, function(r) {
          defer.reject(r)
        })
      })(promises[i], i)
    }
    return defer.promise
  }, async:function(generatorFunc) {
    return function() {
      var generator = generatorFunc.apply(this, arguments);
      function doAction(action, arg) {
        var result;
        try {
          result = generator[action](arg)
        }catch(e) {
          return new Reject(e)
        }
        if(result.done) {
          return result.value
        }
        return when(result.value, next, throwEx)
      }
      function next(v) {
        return doAction("next", v)
      }
      function throwEx(e) {
        return doAction("throw", e)
      }
      return next()
    }
  }});
  return Promise
});

